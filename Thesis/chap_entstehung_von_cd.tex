\chapter{Entstehung und Konzepte von \cd}\label{konzepte_cd}

Um die Funktionalitäten der zu untersuchenden Werkzeuge verstehen zu können, ist eine Betrachtung der Konzepte \cd\ notwendig. Dieser Abschnitt behandelt eingehend die Problemstellung von \cd , denen mit den hier vorgestellten Konzepten begegnet werden soll. Hinter den Ideen von \cd\ steht die \devops -Bewegung. Aus \devops\ leiten sich technische und organisatorische Implikationen wie \zb\ die \emph{Definition of Done}, der \rc , die Prozessautomatisierung und das Fast"=Feedback an das Entwicklungsteam ab. Wesentliche Beförderer dieses Themenkomplexes sind Jez Humble und David Farley, die in ihrem Buch \cd\ und die \dpipe\ zusammenhängend darstellen und Lösungsstrategien für technische Fragestellungen anbieten.\footnote{Vgl. \cite{CD}} \cd\ berührt durch das automatisierte Auslieferungsverfahren auch die Domaine der ITIL Service Transitions gerade im Bereich von Service- und Release"=Management. Am Ende des Abschnitts wird mit einem Exkurs auf die gegenseitigen Implikationen von \cd\ und ITIL eingegangen.

\section{Die \devops -Bewegung}

%\comment{\cd\ ist ein Thema aus der DevOps-Bewegung. Das Zusammenwachsen von Entwicklung und Betrieb kann z.B. durch \cd\ verbessert bzw. sogar erst ermöglicht werden. Das soll hier beschrieben und geprüft werden. Ein \dpipe\ stellt im weiten Sinne einen Eingriff des Entwicklers in den klassischen Aufgabenbereich des IT-Betriebes ein. Wird das bei der umgesetzten Pipeline der Fall sein oder wächst IT-Betrieb und Entwicklung nicht näher zusammen?}

In der belgischen Stadt Genth fand unter dem Titel \devops -Days im Jahr 2009 eine Konferenz zu den Themen Build\footnote{Build bezeichnet den das Kompilieren und Paketieren von Quellcode.}, Softwaretest und Deployment\footnote{Deployment bezeichnet das Ausliefern von Softwarepaketen in eine Ausführungsumgebung. Dies kann \zb\ eine Webanwendung sein, die von einem Webserver ausgeführt wird} statt.\footnote{Vgl. \cite{cd_devops_1}} Die Seite \url{www.DevOps.com} begrüßt seine Besucher mit dem Slogan \mycite{Helping finish what Agile development started}\footnote{\cite{devopsdays.org2012}}. Dieser Slogan beschreibt das eigene Verständnis der \devops -Bewegung. Chris Read schreibt in einem Gastbeitrag über \devops\ wie folgt: \mycite{At its heart it is the integration of Agile principles into Operations practices}. Dies ermöglichte nach seiner Ansicht die Clound- und Web-2.0"=Giganten.\footnote{Vgl. \cite{cd_devops_stateofnation}} \devops\ versucht im Kern die Kommunikation zwischen Systemadministratoren und den Entwicklern der Systeme zu verbessern. Die agilen Praktiken, wie sie zwischen Entwicklern und ihren Kunden schon flächendeckend betrieben werden, sollen auch zwischen IT"=Betrieb und Softwareentwicklern implementiert werden. Auch \hf\ sind in ihrem Buch der Ansicht, dass agile Techniken zum Managen von Infrastrukturen sehr gut geeignet sind.\footnote{Vgl. \cite[S. 279]{CD}}

\begin{wrapfigure}{r}{0.4\textwidth}
\centering
\fbox{\includegraphics[width=\linewidth]{Grafiken/devops.png}}
\quelle{\cite{pant09}}
\caption[Schnittmenge \devops .]{\devops\ als Schnittmenge von Entwicklung, IT"=Betrieb und Qualitätssicherung.}
\end{wrapfigure}

Nach Ansicht von Stephen Nelson"=Smith bereitet vornehmlich die Angst der Unternehmensführung und des IT"=Managements, Änderungen an einer laufenden Anwendung vorzunehmen, Probleme bei der Entwicklung von Software mit kurzen Releasezyklen. Zudem werden häufig bürokratische Prozesse wie das Change"=Management von ITIL, welche für die Compliance eines Unternehmens wichtig sind, von der Unternehmensführung als Argument genutzt, eine Änderung von laufenden Systemen an hohe Anforderungen zu knüpfen. Nach Einschätzung von Nelson"=Smith kommt es hierdurch zu einem merklichen Zeitverlust, wenn ein neues Feature oder ein Bug"=Fix eingespielt werden soll.\footnote{Vgl. \cite{cd_devops_1}}

Bei der Auslieferung von Software in die Produktivumgebung treten erhebliche Risiken auf, die den fehlerfreien Betrieb der Anwendung gefährden können. Dabei gibt es keine vollständige Sicherheit, ob die Software in der geplanten Umgebung wie erwartet läuft oder \zb\ für Webanwendungen die Lastanforderungen durch steigende Nutzerzahlen erfüllt werden können. Nelson"=Smith zielt dabei auf Projektszenarien ab, bei der die Lauffähigkeit einer Anwendung, durch Build-Prozess und Testdurchlauf, nur auf den Arbeitsgeräten der Entwickler bewiesen wird. Ein Test, in einer dem Produktivsystem angelehnten Umgebung, wird aus Zeit- und Kostengründen nicht durchgeführt.\footnote{Vgl. \cite{cd_devops_1}} 

Bei Webanwendungen kommen häufig mehrere Komponenten wie Web- und Applikationscontainer, Frameworks, Datenbankserver oder ein ganzer Server"=Cluster zum Einsatz. Ein Testsystem, welches der späteren Produktionsumgebung entspricht, verursacht zusätzliche Kosten, da weitere Infrastruktur und Wartungsaufwände für die Test"=Systeme hinzukommen. Hat ein Entwickler Bedarf eine neue Komponente zu testen, können je nach Organisation des IT"=Betriebs mehrere Tage vergehen, bis die notwendige Infrastruktur für einen Kapazitätstest zur Verfügung steht. In den kurzen Entwicklungszyklen agiler Methoden bedeutet dies einen empfindlichen Zeitverlust, bis die Reife der neuen Komponente bewiesen und im Produktionssystem laufen kann.\footnote{Vgl. \cite{cd_devops_1}}

Smith"=Nelson führt weiter an, dass zwischen IT"=Betrieb und Entwicklern häufig ein \mycite{Bunkerdenken} existiert, in der jeder Beteiligter in seiner fachlichen Domaine eines Entwicklers, Testers, Release"=Managers oder Systemadministrators denkt, als produktiv an der Verwirklichung neuer gewinnbringender Funktionalitäten zu wirken. Bei Fehlern werden häufig Aufgaben oder Schuldzuweisungen zwischen den geschaffenen Domainen hin und her geschoben.\footnote{Vgl. \cite{cd_devops_1}}

Humble sieht in der generellen Aufteilung von Entwicklung und IT"=Betrieb als auch durch das Governance"=Framework ITIL und Cobit den Wunsch nach stabil laufenden Systemen. Seiner Ansicht nach soll hierdurch verhindert werden, dass die Entwickler einen zu großen Schaden durch neue und noch nicht vollständig ausgereifte Funktionalitäten am Produktivsystem verursachen könnten. Die Entwicklung und Einführung neuer Funktionalitäten wird so verlangsamt.\footnote{Vgl. \cite{devops_enterprise}}

Damon Edwards schreibt, dass es sich bei \devops\ nicht um ein technologisches sondern viel mehr um ein betriebswirtschaftliches Problem handelt. Technologie nimmt aber die Schlüsselrolle ein, wenn es darum geht, dieses betriebswirtschaftliche Problem auch zu lösen. Bei der Entwicklung einer neuen Software steht immer das betriebswirtschaftliche Problem im Vordergrund. Dies könnte \zb\ die Erschließung eines neues Marktes über das Internet sein. Der Nutzen, der aus der Entwicklung eines neuen Online"=Shops gezogen werden soll, ist die Erwirtschaftung von Gewinn. Um dieses Ziel zu ermöglichen, müssen alle Beteiligten im Prozess wie Entwickler, Qualitätssicherung und IT"=Betrieb, eng zusammenarbeiten. Für Edwards steht folgende Frage bei \devops\ im Vordergrund: \mycite{How to enable a business to react to market forces as quickly as possible?}\footnote{Vgl. \cite{edwards10}}

Nach Nelson"=Smith müssen Entwickler, Tester, Manager, Administratoren von Datenbanken, Netzwerktechniker und Systemadministratoren das selbe Ziel verfolgen, gute Software liefern. Dabei fordert er Entwicklungsteams die die Kompetenz eines \mycite{sysadmin coders} besitzen. Dies ist ein Team, welches die Fähigkeiten, Kompetenzen und Rechte des IT"=Betriebs und der Softwareentwicklung auf sich vereint.\footnote{Vgl. \cite{cd_devops_1}}

Für Read besteht eine Definitionslücke zwischen \mycite{dev complete}, also der Fertigstellung der Entwicklung einer Anwendung oder einzelnen Features und \mycite{live, in production, stable, making money}. Typischerweise sind Systemadministratoren in der Verantwortung und der Pflicht eine neue oder aktualisierte Anwendung, deren genaue Funktionsweise sie nicht kennen, in die Produktivumgebung auszurollen und deren Betrieb sicherzustellen. Dementsprechend ist auf dieser Seite mit Vorbehalten und Vorsicht zu rechnen, wenn es darum geht, neue Software einzuführen. Wie Nelson"=Smith ist auch Read der Ansicht, dass Entwicklungsteams alle Disziplinen besetzen sollten, die notwendig sind, um eine Anwendung nicht nur entwickeln sondern auch betreiben zu können.\footnote{Vgl. \cite{cd_devops_stateofnation}}

Chad Dickerson, CEO bei Etsy, berichtete, dass bei Etsy Designer, Produktmanager, Entwickler und Administratoren sehr eng an der Verwirklichung neuer Funktionalitäten zusammenarbeiten. Etsy erreicht durch \devops\ und der Automatisierung bis zu 517 Deployments in das Produktivsystem im Monat. Diese werden von bis 63 unterschiedlichen Mitarbeitern angestoßen. Möglich wurde diese auch durch den Einsatz von \dpl .\footnote{Vgl. \cite{devops_dickerson}}

Für Read helfen folgende Ansätze, \devops\ zu ermöglichen:\footnote{Vgl. \cite{cd_devops_stateofnation}}

\begin{itemize}
\item Die Auflösung verwurzelten Funktionsstrukturen im Unternehmen die verhindern, dass Entwicklungsteams sich aus Programmierern, Testern, Business"=Analysten, Administratoren zusammensetzen können. Falls dies nicht möglich sein sollten, ist eine enge Verbindung zwischen IT"=Betrieb und Entwicklern sowie allen sonstigen Beteiligten herzustellen und agile Praktiken im IT"=Betrieb einzuführen.
\item Investition in die Automatisierung von Administrationsvorgängen, wie das Ausrollen einer neuen Softwareversion. Hier kann eine \emph{Tool"=Chain}, die Aneinanderreihung von geeigneten Werkzeugen, einen Mehrgewinn bedeuten.
\item Das operative Risiko durch Softwareaktualisierungen kann gesenkt werden, wenn nur kleine dafür aber kontinuierliche Änderungen am System vorgenommen werden.
\item Eine Cloud"=Strategie im Unternehmen ermöglicht es dem Entwicklungsteam sich schnell und einfach mit Test- und Produktivsystemen selbst zu versorgen.
\item Allen an der Entwicklung eines Dienstes oder einer Anwendung Beteiligten sollte die gemeinsame Verantwortung für eine qualitative Lieferkette bewusst sein.
\end{itemize}

Die Einführung einer \devops -Kultur ist für Read die Grundlage, um \cd\ zu betreiben. \cd\ wiederum löst die Probleme von \devops . Die Umsetzung von \cd\ für ein spezifisches Projekt wird dementsprechend auch die Probleme von \devops\ berühren.\footnote{Vgl. \cite{cd_devops_stateofnation}}


\section{Problemstellung von \cd}

%\footnote{Vgl. \cite[S. 174 f]{steinweg04}}

%\comment{Welche Problem versucht \cd\ zu lösen? Was sind die Ursachen, die zu diesem Ansatz geführt haben? Diese Frage ist wicht, um zu verstehen was \cd\ zu lösen versucht und warum die Arbeit sich mit diesem Thema beschäftigt. Hier muss die Einleitung aufgegriffen werden und mehr in das Detail gegangen werden.}

Für \cd\ können vier verschieden Problemfelder ausgemacht werden. Die im nachfolgenden Abschnitt vorgestellten Konzepte versuchen diese zu lösen.

\paragraph{Ausnutzung des Wertzuwachses durch iterative Softwareentwicklung:}

Bei Web"=2.0"=Anwendungen ist der Erfolg auch davon abhängig, neue Funktionalitäten möglichst schnell und vor der Konkurrenz bereitstellen zu können. Diese Fähigkeit kann zu einem hohen Maße den wirtschaftlichen Erfolg positiv beeinflussen.

Der iterative Ansatz der agilen Softwareentwicklung produziert, wenn entsprechend organisiert, die Funktionalitäten mit dem höchsten Kundennutzen an erster Stelle. Nützliche und funktionierende Software sollte nach \hf\ den Anwendern auch schnellstmöglich zur Verfügung gestellt werden.\footnote{Vgl. \cite[S. 11]{CD}}

Einen Gegenentwurf zu diesem Vorgehen, dem sich Dienstleister in einem typischen Kunden"=Lieferanten"=Verhältnis gegenübersehen, stellt der reguläre Einführungsprozess von Software dar. Hier fließen Werkabnahme, Pilotbetrieb, Abnahme und Erfüllung aller Anforderungen, Roll"=Out und Going"=Live sequenziell ineinander.\footnote{Vgl. \cite[S. 169 ff]{steinweg04}} Ein neues Feature schnell und einfach in die Produktion zu bringen, auch wenn nach agilen Methoden vorgegangen wird, ist mit einem derartigen Prozess schwer möglich. Der Abnahmeprozess für eine neue Software ist aufwendig aber notwendig, da der Kunde verpflichtet ist, das Werk abzunehmen. Jede Lieferung in die Produktivumgebung würde auch zu einer notwendigen Abnahme des Werkes führen. In einem Dienstleitungsverhältnis können diese Begleitumstände aber abgemildert werden.

Der Softwarelieferprozess muss darauf ausgerichtet werden, die Vorteile die sich aus den iterativen Vorgehen agiler Modelle ergeben, auch gewinnbringend ausnutzen zu können. Dieser Softwarelieferprozess sollte unabhängig davon sein, ob es sich um eine Web"=Anwendung mit tausenden anonymen Nutzern oder um eine Anwendung im Back"=Office einer Versicherung mit nur 100 Nutzern zu gewöhnlichen Bürozeiten handelt.

\paragraph{Einspielen eines Hot-Fix:}

Ein kritischer Systemfehler in einer Banking"=Software, der erst einige Wochen nach der Abnahme auffällt, erfordert einen hohen Personalaufwand und verursacht unnötige Kosten. Diese entstehen vorwiegend bei der Fehlersuche, da die Implementierung der fehlerhaften Stelle möglicherweise schon Monate zurückliegt und die Erinnerung der Entwickler nicht mehr frisch ist. Zudem kommen Aufwände für die Vorbereitung des Release sowie für das Einspielen des Bugfixes hinzu. Die Aufwände, die hierdurch entstehen, sind unabhängig davon, ob sich es bei der fehlerhaften Stelle nur um ein einzelnes Zeichen oder eine größere Änderung handelt.

Ist eine Hot"=Fix einzuspielen, geht dem häufig die Situation voraus, dass die Produktivumgebung nicht ordnungsgemäß arbeitet. Möglicherweise ist \zb\ ein Web"=Shop nicht mehr zu erreichen oder berechnet Preise falsch. Der dringende Bedarf, dieses Fehlverhalten schnellstmöglich zu beseitigten, führt dann zu einem Umgehen des regulären Lieferprozesses und der Qualitätssicherung. Neue kritische Fehler und Sicherheitslücken können so schnell in die Software einschleichen.

Bei einer kontinuierlichen Auslieferung der Software durch einen automatisierten Prozess könnten derartige Risiken minimiert werden. Eine fehlerhafte Implementierung, die auch durch eine sorgfältige Qualitätssicherung nicht erkannt wird und erst in der Produktivumgebung erkannt wird, ist schnell auf die letzte Änderung einzugrenzen. Die Fehleridentifizierung kann hierdurch beschleunigt werden und das fehlerhafte Verhalten schnell beseitigt werden.

Der Softwarelieferprozess muss auch die Lücke schließen können, die durch die schnelle Beseitigung eines Fehlers auftritt. Die qualitative Auslieferung von Software muss auch für schnelle Hot"=Fixes gelten. Das Umgehen des regulären und auf Qualitätssicherung gestützten Lieferprozesses sollte auch für das schnelle Einspielen eines Notfallpatches nicht hingenommen werden. Ein automatisierter Prozess garantiert auch für Hot"=Fixes eine gleichbleibende Qualität.

\paragraph{Komplexität der Softwarelieferung:}

Der Softwarelieferprozess ist das Ausrollen einer neuen Software in die Produktivumgebung. Dieser Prozess ist mit einem hohen Aufwand an Vorbereitung und personellen Ressourcen verbunden. Ein Beispiel aus dem Projektkontext von adesso ist das Ausrollen einer neuen Softwareversion bei einem großen Versicherer. Dieser Vorgang konnte nur als \mycite{Night"=Session} durchgeführt werden nachdem das reguläre Personal gegangen war. Um die neue Version der Anwendung zu installieren sind Server nacheinander herunter gefahren, anschließend aktualisiert und wieder hochgefahren worden. Ein \emph{Smoke"=Test} zeigte die grundlegende Funktionalität der Anwendung. In dieser Situation war das gesamte Team hochgradig angespannt, da nicht endgültig zweifelsfrei vorher geprüft werden konnte, ob der Aktualisierungsvorgang gelingt und das System anschließend wieder seinen regulären Dienst aufnimmt.

Ein manueller Lieferprozess kann nach Ansicht von \hf\ vielschichtige Fehler verursachen, deren Gründe sich nicht immer unmittelbar identifizieren lassen. Der manuelle Lieferprozess ist fragil, da er auf das korrekte und disziplinierte Vorgehen der Ausführenden angewiesen ist. Ein automatisierter Prozess kann diese Komplexität mit einem einmaligen Aufwand in die Automatisierung einfangen. Der Prozess ist dann immer in gleichbleibender Qualität ausführbar.\footnote{Vgl. \cite[S. 5-10]{CD}}

\paragraph{Spätes Feedback:}

In dem von Steinweg beschriebenen Einführungsprozess für neue Software ist ein Pilotbetrieb dieser vorgesehen. Beim Pilotbetrieb wird eine Software durch einen ausgewählten Nutzerkreis zukünftiger Anwender auf Performanz und Stabilität geprüft. Der Pilotbetrieb folgt auf die vorläufige Werkabnahme, was die Fertigstellung der Anwendung aus Sicht des Herstellers impliziert. Werden im Pilotbetrieb Fehler ausfindig gemacht, ist der Hersteller zur Nachbesserung verpflichtet.\footnote{Vgl.\cite[S. 179 ff]{steinweg04}}

Werden Fehler in dieser Phase noch ausfindig gemacht, sind diese vom Entwicklungsteam nur noch mit hohem Aufwand zu beheben. Die Lokalisierung der Fehler ist zeitaufwändig, da zwischen Implementierung und Auslieferung mehrere Monate vergangen sein können. Dieses Vorgehen bezeichnen \hf\ als ein \mycite{common release antipattern} für den Softwarelieferprozess.\footnote{Vgl. \cite[S. 7 ff]{CD}} Zudem ist in dieser Phase der durchaus nützliche Input des Testteams der Pilotphase kaum noch verwertbar. Das Agile Manifest stellt die schnelle Bereitstellung von funktionierender Software sowie ein schnelles Feedback an das Entwicklungsteam in den Mittelpunkt des Softwareentwicklungsprozesses.\footnote{Vgl. \cite{manifesto}}

Der Softwarelieferprozess selbst sollte dem Entwicklungsteam ein frühestmögliches Feedback über den Zustand der Quellcode"=Basis und damit der Software ermöglichen. Je früher ein Fehlverhalten aufgedeckt wird, desto einfacher und effizienter wird deren Beseitigung.

%\section{\cd\ und das Agile Manifest}

%\comment{\cd\ stellt eine Verbindung zum agilen Manifest her, da es als logische Konsequenz aus dem agilen Manifest angesehen werden kann. Dieser Zusammenhang muss zuvor erläutert werden und stellt die Verbindung zu agilen Vorgehensmodellen her.}

\section{Konzepte von \cd}

%\comment{\cd\ wird mit bestimmten Vorzügen beworben. Diese bauen direkt auf der schon beschriebenen Problemstellung auf und stellen diese aber klarer heraus. Dieser Schritt ist notwendig, da hier die zu untersuchenden Werkzeuge gegen die formulierten Ziele und Vorzüge geprüft werden kann. Sind die Vorzüge bei der späteren Umsetzung der \dpipe\ auch zu beobachten?}

Die nachfolgend beschriebenen Konzepte basieren auf der Arbeit von \hf , die diese in ihrem Buch über \cd\ geben. Diese Konzepte stellen, dem Erachten von \hf\ nach, die notwendige Basis dar, um eine zentrale und automatisierte \dpipe\ für den Softwarelieferprozess zu implementieren.\footnote{Vgl. \cite[S. 3 ff]{CD}}

\subsection{Feedback-Prozess}

Software kann in vier Komponenten zerlegt werden: der ausführbare Code, die Konfiguration der Software, die Laufzeitumgebung und Daten mit denen die Software arbeitet. Das Verhalten der Anwendung wird von allen vier Komponenten beeinflusst, was es erfordert, alle Komponenten unter Kontrolle zu halten. Eine Möglichkeit diese Kontrolle auszuüben ist jede Änderung an der Quellcode"=Basis in ausführbare Software zu wandeln, also zu kompilieren, und in ihrer geplanten Ausführungsumgebung zu testen. Das Entwicklungsteam erhält so ein schnelles Feedback, welches hilft, die Qualität des aktuellen Softwarestandes zu beurteilen. Kommt es zu einem Fehler, kann dieser schnell identifiziert und behoben werden.

Unabhängig davon, ob es sich um ein Testsystem oder das Produktivsystem handelt, sollte es keine Änderung der erstellten Softwarepakte, im weiteren Verlauf allgemein als Binaries bezeichnet, mehr geben. Werden die Binaries vor Auslieferung in die Produktivumgebung neu kompiliert und es kommt zu unerwarteten Fehlern im Produktivsystem, kann nicht sicher ausgeschlossen werden, dass diese Fehler erst durch das erneute Kompilieren auftraten. Einmal kompilierte Binaries sollten während des gesamten Lieferprozesses nicht mehr verändert werden. Ein dann auftretendes Fehlverhalten im Produktivsystem kann so \zb\ auf eine veränderte Konfiguration eingegrenzt werden.

Unterschiedliche Umgebungen erfordern auch häufig unterschiedliche Konfiguration der Software. Konfigurationsparameter für unterschiedliche Ausführungsumgebungen sollten, \hf\ zufolge, die einzigen veränderbaren Werte sein. Ändern sich diese Daten, muss die Anwendung auf die neuen Einstellungen hin getestet werden.

Zum Feedback über den Zustand der Quellcode"=Basis gehört die Qualitätssicherung durch Softwaretests. Komponenten- bzw. Unit"=Tests gehören zur ersten Stufe des Feedback"=Prozesses. Dieser soll zeigen, dass sich alle Komponenten, losgelöst betrachtet, der Erwartung entsprechend verhalten.

Der Test von einzelnen Komponenten kann nur eine Aussage über das Verhalten einzelner Methoden und Klassen der Anwendung liefern. Ob die Komponenten und Module einer Anwendung wie erwartet zusammenarbeiten, müssen Integrationstests ermitteln. Diese bilden die zweite wichtige Stufe im Feedback"=Prozess und erfordern die Ausführung der Anwendung in einer dem Produktionssystem angelehnten Umgebung. Nimmt ein Entwickler eine Anpassung einer Funktionalität vor, bei der ein auf dem Entwicklungssystem ausgeführter Komponententest keine Fehler anzeigt, ist noch nicht sichergestellt, dass die Änderung keinen negativen Einfluss auf \zb\ abhängige Komponenten hat. Das korrekte Zusammenspiel aller Komponenten wird durch Integrationstests sichergestellt. Scheitert dieser an der neuen Version, obwohl die vorherige Version stabil lief, kann die Ursache schnell aus dem Änderungsprotokoll der Versionsverwaltung ermittelt und die fehlerhafte Stelle angepasst werden.

Die dritte Stufe des Feedback"=Prozesses, die eine Aussage zum Zustand der Quellcode"=Basis ermöglicht, ist die Prüfung der Akzeptanzkriterien. Dabei wird die Erfüllung der für die Abnahme der Software relevanten funktionalen und nicht"=funktionalen Anforderungen geprüft. Können diese kontinuierlich mit jeder Änderung der Quellcode"=Basis geprüft werden, kann eine Aussage zur Lieferfähigkeit einer jeden Version gemacht werden.\footnote{Vgl. \cite[S. 13 ff]{CD}}

Ein guter Ansatz, um in einem neuen Projekt frühzeitig zu einer Aussage über den Erfüllungsgrad der Akzeptanzkriterien zu kommen, ist die Umsetzung von Behavior"=Driven"=Development, kurz BDD. BDD ist eine Weiterentwicklung des Test"=Driven"=Development, kurz TDD. Bei TDD werden Komponententests einer neuen Funktionalität vor deren Implementierung erstellt. Nach Dan North besteht ein wesentliches Problem bei der Umsetzung von TDD darin, dass Entwickler am Anfang nicht genau wissen, wo sie beim Testen beginnen bzw. was konkret sie testen sollen und wie viel. Dan North versuchte diese Probleme zu lösen und dabei die guten Seiten von \emph{TDD} noch mehr mit den agilen Methoden zu verknüpfen. Beim BDD"=Ansatz werden aus den Akzeptanzkriterien, mit den Schlüsselwörtern \emph{given}, \emph{when} und \emph{then}, Testfälle generiert. Akzeptanzkriterien können so vor dem Beginn der Entwicklungsarbeit, bzw. auch parallel zu diesen, in automatisierte Testfälle umgesetzt werden.\footnote{Vgl.  \cite{North}}

\subsection{Zugewinn für das Entwicklungsteam}

Der Nutzen von \cd\ liegt in der Vereinfachung des Deployment"=Prozesses. Das Entwicklungsteam, das Test"=Team, der IT"=Betrieb und der Support soll in die Lage versetzt werden, einen bestimmten Softwarestand in eine beliebige Ausführungsumgebung deployen zu können. Kern dieser Ideen ist ein Self"=Service"=Portal. Durch dieses Portal könnte sich das Test"=Team die aktuelle Version der Anwendung in eine Testumgebung selbst deployen, um \zb\ explorativ zu testen oder Design und Layout zu überprüfen. Das Support"=Team kann einen aus dem Testdurchlauf und vom \emph{Quality"=Gate} als lieferfähig eingestuften Hot"=Fix in die Produktivumgebung ausrollen lassen.

Durch die Möglichkeit, jede Version einer Software, auch ältere, in eine bestimmte Umgebung bereitstellen zu können, können plötzlich auftretende und bisher unbekannte Verhaltensweisen einer verifiziert werden. So kann geprüft werden, ob ein Verhalten auch schon in vorhergehenden Versionen aufgetreten ist und bisher nur nicht entdeckt wurde oder es sich um ein neues Fehlverhalten handelt. Auf diese Weise kann das Auftreten ein Fehlverhalten auf eine bestimmte Änderung zurückgeführt werden.  Zudem kann bei Bedarf jederzeit auf eine ältere Version mit Knopfdruck zurück gewechselt werden die als stabil bekannt ist.

\hf\ weisen besonders auf den zunehmenden Druck vor einem geplanten Release hin, der auf dem Entwicklungsteam lastet. Die Motivation des Entwicklungsteams fassen sie wie folgt zusammen: \mycite{Just get something working}. Die Möglichkeit am Tag des Release, dieses einfach mit einem einfachen Knopfdruck ausführen zu können, schafft Freiräume für die eigentliche Tätigkeit, qualitative Software zu erstellen. Geht beim Deployment in die Produktivumgebung doch etwas schief, kann die vorherige Version schnell wieder hergestellt werden.

\hf\ sind der Ansicht, je häufiger ein Release durchgeführt wird, desto kleiner ist das Delta zwischen neuer und alter Version und so geringer das Risiko unerwarteter Fehler. Der Softwarelieferprozess wird nach ihrer Ansicht damit stabiler und verlässlicher.\footnote{Vgl. \cite[S. 17 ff]{CD}}

\subsection{Der \rc}

In einem automatisierten Lieferprozess ist es erforderlich, die Eigenschaften einer lieferfähigen Software zu definieren. Hierfür führen \hf\ das Konzept des \rc\ ein.

Jede Änderung an der Code"=Basis führt möglicherweise zu lieferfähiger Software, einem \rc . Ob eine bestimmte Version der Software auch die Eigenschaften eines \rc\ besitzt, muss zuvor validiert und getestet werden. Ein \rc\ ist eine bestimmte Version, in der keine Fehler in den Komponenten- und Integrationstests gefunden wurden, die Metriken wie Code"=Abdeckung sowie alle funktionalen und nicht"=funktionalen Akzeptanzkriterien erfüllt werden konnten.

Jede Änderung an der Quellcode"=Basis fügt der Software einen Wert hinzu. Im Gegensatz hierzu können sich mit jeder Änderung auch Fehler in das System einschleichen. Eine Überprüfung erfordert die Ausführung des Systems in einer an das Produktivsystem angelehnten Umgebung. Dies ist ein Prinzip von \ci , kurz CI. \ci\ stellt einen Grundpfeiler für die \dpipe\ in \cd\ bereit. 

\hf\ führen an, dass bei Projekten, die nicht kontinuierlich ein Release in eine an die Produktivumgebung angelehnte Testumgebung durchführen, die Integration der Anwendung mit allen zugehörigen Komponenten gerne in eine spätere Projektphase verschoben wird. Nach der Erfahrung von \hf\ ist die Integration eines Softwaresystems unvorhersehbar und schwer zu handhaben. Je später die Integration des Gesamtsystems erfolgt, desto aufwendiger wird die Zusammenführung sowie die Beseitigung von Fehlern, die erst zu diesem Zusammenhang sichtbar werden. Je früher die Integration des Gesamtsystems betrieben wird, desto geringer der Aufwand. Der \rc\ integriert frühestmöglich alle Komponenten miteinander und stellt die kontinuierliche Lieferfähigkeit der Software her.\footnote{Vgl. \cite[S. 22]{CD}}

\subsection{Implementierung eines wiederholbaren und verlässlichen Lieferprozesses}

Um \cd\ verwirklichen zu können, müssen, nach Ansicht von \hf , die nachfolgend beschriebenen Prinzipien umgesetzt werden.\footnote{Vgl. \cite[S. 24]{CD}}

Wenn Software gut getestet wird, sollte es einfach sein, diese in die Produktivumgebung ausliefern zu können. Das Deployment einer neuen Version sollte nur einen Knopfdruck bedeuten. Automatisiert werden sollen alle Teilschritte im Softwarelieferprozess wie Build, Test und Deployment. Ein automatisiertes Deployment setzt voraus, dass die Zielumgebungen mittels Programm oder Konfiguration verwaltet und gesteuert werden können. Zur Laufzeit der \dpipe\ müssen möglicherweise benötigte Softwarekomponenten und Infrastrukturdienste installiert oder angepasst werden.

Manuelle Stufen im Softwarelieferprozess bleiben das explorative Testen, die Demonstration der Funktionsfähigkeit und die Compliance. Compliance beschreibt die Einhaltung von Regelungen, die für eine IT"=Landschaft in einem Unternehmen getroffen wurden oder durch gesetzliche Bestimmungen eingehalten werden müssen, um einen bestimmten IT"=Service bereitstellen zu können.\footnote{Vgl. \cite{Teuteberg2011}}

\hf\ gehen davon aus, dass die Schritte, die in einer automatisierten \dpipe\ ablaufen, am Anfang einfacher sind, diese manuell auszuführen. Nach der zehnten manuellen Ausführung ist es aber ein typisches menschliches Verhalten, diese Vorgänge ungenauer und weniger konzentriert als beim ersten Mal durchzuführen. Auf diese Weise wird der Prozess fragil und ist von der Disziplin der Beteiligten abhängig, die aber nicht erwarten werden darf. Deshalb plädieren sie, zu Beginn eines Projektes in die Automatisierung des Deployments zu investieren.

Der Versionsverwaltung wird in diesem Prozess eine zentrale Bedeutung zugeschrieben. Neben der Verwaltung der Quellcode"=Basis müssen die Konfigurationselemente der Ausführungsumgebungen verwaltet werden. Führt die Änderung der Einstellung zu einem Fehler im Test- oder Produktivsystem, ist es leicht, über die Versionsverwaltung die fehlerhaften Einstellungen zu identifizieren. Solche Konfigurationselemente können \zb\ Test"=Skripte, Netzwerkeinstellungen, Deployment"=Skripte, Datenbank"=Skripte, Installationsskripte für Infrastrukturkomponenten, benötigte Bibliotheken und technische Dokumentationen sein.

Ein zentraler Lieferprozess ist neben der technischen Komponente auch eine organisatorische Aufgabe. In kleineren Teams besteht zumeist die vollständige Kontrolle über die benötigten Ressourcen. Größere Unternehmen bauen durch ihre Organisationsstrukturen möglicherweise auch Kommunikationsbarrieren zwischen den Beteiligten im Entwicklungs- und Lieferprozess ein. Entwickler, Tester und Systemadministratoren sind dann unterschiedlichen Organisationseinheiten unterstellt und räumlich voneinander getrennt. Die Ziele von \devops\ geben hier einen guten Ansatzpunkt, um Strukturen zu schaffen, in der eine Kultur der ungehinderten Kommunikation mit einer gemeinsamen Verantwortlichkeit für Qualität und Nutzen eines IT"=Dienstes entsteht.

Ein weiterer zentraler Gedanke, der auf die \devops -Idee aufbaut, ist die \emph{Definition of Done}. Nach \hf\ ist ein neues Feature erst dann als fertig anzusehen, wenn es fehlerfrei in der Produktionsumgebung ausgeführt werden kann. \emph{Done} bedeutet, dass eine Funktionalität einer Software erfolgreich einer repräsentativen Nutzergruppe demonstriert und durch diese ausprobiert wurde. Diese führt zurück zur Notwendigkeit des Pilotbetriebs mit einem eingeschränkten Benutzerkreis, dieser unterliegt hier aber dem iterativen Vorgehen agiler Softwareentwicklung und wäre dann für einzelne Funktionalitäten durchzuführen.\footnote{Vgl. \cite[S. 178]{steinweg04}}

Bei \hf\ ist der Lieferprozess kein statisches System, welches implementiert und dann unverändert betrieben werden kann. Viel mehr sehen sie die Notwendigkeit, diesen Prozess in einem \mycite{continuous improvement} zu entwickeln. Die erste Implementierung der \dpipe\ steht am Anfang eines Projektes, mit den minimal möglichen Schritten, das geplante System in die Produktivumgebung auszuliefern. Mit der Umsetzung der geplanten Funktionalitäten nimmt das System an Größe und Komplexität zu. Die \dpipe\ muss den geänderten Anforderungen kontinuierlich angepasst werden. Hierzu gehören neue Maßnahmen der Qualitätssicherung, die Implementierung von Quality"=Gates oder die Berücksichtigung der Datenbank in der \dpipe .

\section{Exkurs: ITIL und \cd}

ITIL ist ein Referenzmodell für die Compliance eines Unternehmens und stellt einen Leitfaden für das IT"=Service"=Management bereit. \cd\ berührt mit dem Konzept einer automatisierten \dpipe\ besonders den Bereich der Service"=Transition. ITIL Service"=Transition beschreibt Prozesse und Verfahren, um neue oder auch geänderte IT"=Services in den operativen Betrieb zu heben. Die Service"=Transition folgt auf das Service"=Design und mündet dann in Service"=Operation. Die Kernprozesse von Service"=Transition sind Transition"=Planning \& Support, Change"=Management, Service"=Asset \& Configuration"=Management, Release"=Management, Release \& Deployment"=Management.\footnote{Vgl. \cite{itil_boetcher}}

Das Change- und Release Management ist bei der Implementierung einer \dpipe\ zu beachten, wenn \zb\ der Kunde, für den ein neuer IT"=Dienst umgesetzt werden soll, intern nach dem ITIL Compliance"=Framework vorgeht.\footnote{Vgl. \cite{itil_boetcher}}

Erik Minck ist der Ansicht, dass das Change- und Release"=Management von ITIL Synergien mit \devops\ besitzt und die gleichen Ziele verfolgt, schnell nutzbringende und qualitative IT"=Dienste und Anwendungen bereitstellen zu können.\footnote{Vgl. \cite{DevOpsITIL}}

Ein wichtiges Merkmal im Release Management ist der Erhalt der Systemintegrität der bestehenden Infrastruktur. Unvorhergesehene Beeinträchtigungen müssen vor der Einführung neuer oder geänderter Dienste vermieden werden.\footnote{Vgl. \cite[S. 108]{itil_boetcher}}

ITIL hat vornehmlich in größeren Unternehmen Rückhalt, da bei diesen eine risikoscheue Haltung im IT"=Betrieb zu beobachten ist. Bei kleineren Unternehmen und Start"=Ups sind hingegen häufiger die Konzepte von \devops\ anzufinden.\footnote{Vgl.  \cite{DevOpsITIL}}

Zu den Aktivitäten im Change"=Management, der Ablaufsteuerung für Veränderungsmaßnahmen, gehört die Dokumentation aller Änderungsanfragen, der \emph{R}equest \emph{F}or \emph{C}hange, das Zulassen und die Beurteilung der RFCs, die Autorisierung, die Koordinierung der Implementierung und das Prüfen des Ergebnisses. Aktivitäten im Release"=Management sind die Erstellung von Release"=Richtlinien, die Planung eines Release, die Erstellung von Testfällen, die Steuerung der Implementierung, der Support bei der Einführung und der Abschluss des Projektes. Als Methodiken empfiehlt ITIL die Trennung der Umgebungen für Entwicklung, Test und Produktion sowie die Nutzung von Verteilungswerkzeugen für die neue Software.\footnote{Vgl. \cite[S. 89 ff]{itil_boetcher}}

Die Change- und  Release"=Richtlinien von ITTL weisen in Richtung \cd . \cd\ schlägt die automatisierte Verteilung von Software in die Produktivumgebung vor sowie ein sequenzielles Roll"=Out und die Implementierung einer Push"=Funktionalität. Die Verifizierung eines Release erfolgt in einer möglichst nahen Abbildung der Produktivumgebung durch verschiedene Testverfahren. Verifiziert werden dabei die Fähigkeiten einer Software in die geplante Umgebung installiert werden zu können, der Test der Integration mit den vorhandenen Komponenten sowie eine Untersuchung der Auswirkung auf die Systemstabilität als auch auf das Systemverhalten. Ein neues System muss beweisen, dass es sich wie erwartet verhält.\footnote{Vgl. \cite[S. 114]{itil_boetcher}}

Die \dpipe\ unterstützt das Change- und Release"=Management effektiv und kann unter folgenden Umständen als ein Revisions- und Compliance"=Werkzeug angesehen werden:

\begin{itemize}
\item Der Prozess oder das Werkzeug muss die Version einer Software verwalten, die in einer Umgebung ausgeführt wird.
\item Die Ergebnisse der Zwischenschritte, die innerhalb der Pipeline ablaufen, müssen dokumentiert und ausgewertet werden. Hierzu gehören \zb\ die Testprotokolle der automatisierten Testdurchläufe und die Protokolle der Systemänderungen, wenn automatische Änderungen an der Infrastruktur vorgenommen werden.
\item Es muss ersichtlich sein, welcher Mitarbeiter oder welches System einen Prozess angestoßen hat und wann.
\item Ein spezifisches Deployment muss sich auf eine Revisionsnummer im Versionsverwaltungssystem zurückführen lassen. 
\item Prozessmetriken, wie \zb\ die Durchlaufzeit der einzelnen Phasen müssen dokumentiert sowie ein kontinuierliches Monitoring- und Feedback"=System implementiert werden.  
\end{itemize}

\section{Zusammenfassung}

\devops\ und \cd\ haben einen starken Fokus auf Web"=Technologien. Die Ideen und Konzepte hierzu stammen von Personen, die im Umfeld von Web-2.0"=Anwendungen und Cloud"=Computing sehr aktiv sind. Bei \devops\ geht es um ein gemeinsames und zielorientiertes Zusammenwirken von Entwicklern, Testern und Systemadministratoren. Hierfür werden gemischte Teams vorgeschlagen, die eine gemeinsame Verantwortung für die umzusetzenden Funktionalitäten tragen. Alle im Team leisten dabei einen Betrag, den anvisierten wirtschaftlichen Nutzen zu erzielen. \cd\ beschreibt einen automatisierten Auslieferungsprozess, der dem Entwicklungsteam wiederkehrende Aufgaben abnimmt und diese präziser und schneller ausführen kann. Dem Entwicklungsteam wird durch das Auslieferungssystem ein schnelles Feedback über den Zustand der Quellcode"=Basis gegeben. Im Mittelpunkt stehen automatisierte Komponenten, Integrations- uns Akzeptanztests. Zudem ist jederzeit ersichtlich, welche Version in welcher Umgebung ausgeführt wird. Der automatisierte Auslieferungsprozess reduziert Fehler, die durch manuelles Deployment der Software und manuelles Konfigurieren der Systemumgebung entstehen können. In der zeitkritischen Phase vor einem Release wird durch einen verlässlichen und oft erprobten Lieferprozess, Stress und Druck vom Entwicklungsteam genommen. Dieses kann sich so besser auf die qualitative Umsetzung der Funktionalitäten konzentrieren. Für Unternehmen, die Compliance anstreben, ist \devops\ und \cd\ eine Möglichkeit, die Anforderungen aus dem ITIL Change- und Release"=Management in einer leichtgewichtigen Version zu erfüllen.

%\section{Rechtliche und vertragliche Implikation von \cd}