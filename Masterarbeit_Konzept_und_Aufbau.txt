1. Einleitung: (Einleitung in das Thema, Begr¸ndung sich damit zu bsch‰ftigen, Zielstellung)
	- Beispiel Kent Beck liefert in de 90er Jahren jeden Tag in die Produktivumgebung
	- Agiles Manifest nennt 12 Prinzipien, erstes beinhaltes kontinuierliches Ausliefern
	- Scrum	liefert nach jeder Iteration f¸r den Kunden n¸tzliche Funktionen
	- Bedeutet aber jedes Mal eine Inbetriebnahme
	- Nach ß640BGB Werkabnahme erfolderlich
	- CD soll aber Komplexit‰t reduzieren
!	- CD setzt nicht auf spezielle Basistechnologien auf sondern ist ein Konzept um Prozesse beim Softwarerelease zu automatisieren 
!	- CD im engen Zusammenhang mit DevOps-Bewegung -> Entwicklung und IT-Betrieb m¸ssen enger zusammenarbeiten
!	- CD und DevOps fokusieren nicht speziell Web-Anwendungen, Ideen kommen aber aus dem Web 2.0 / Cloud Umfeld
	- Umsetzung von CD mit Scripten mˆglich, aber keine klarer und wiederholbarer Prozess
	- Problematik hatten auch verschiedene Webprojekte -> Einzellˆsungen und propriet‰re Lˆsungen
	- Vorstellung von adesso als Dienstleister und Softwareentwicklung unter Java / JEE
	- Eigenes Vorgehensmodell advantage stellt f¸hstmˆglich Installation in den Vordergrund
	- Interesse an CD, mit Kernfokus Java / JEE und Web-Anwendungen und Vorschlag von Go, Deployinator und Dreadnot
	- Ziel: Tools untersuchen, Mˆglichkeit such Auslieferungsprozess zu erg‰nzen, Kernfrage CD beleuchten
	- Eingrenzung der Betrachtungsweise zu gunsten von Web-Anwendungen im Java-Technologie-Stack
	- Vor untersuchung der Werkzeugen Betrachtung von CD
		- Ideen von CD ist weiterentwicklung von CI
		- basiert auf Buch von HF und DevOps-Artikel von 

2. Entstehung von CD:
	- Verstehen von CD notwendig um Tools bewerten zu kˆnnen -> Auf Problemstellung von CD wird eingegangen
	- CD in enger Verbindung mit DevOps, was ist die DevOps-Bewegung und was sind ihre Motive. Wie ist CD durch diese beeinflusst
	- Aus DevOps leiten sich Konzepte f¸r CD ab -> Ziele f¸rs Team, Definition of Done und RC, Prozessautomatisierung, Feedback
	- Ein Blick auf ITIL -> CD ber¸hrt die Domaine von ITIL Service-Transition im Bereich von Service- und Release-Management

	2.1 Problemstellung von CD:
		Problem 1: Wertzuwachs einer Iteration oft nicht direkt nutzbar -> Lange Releasezyklen
			- Iteratives Vorgehen in agilen VM priorisiert Funktionalit‰ten und produziert die Funktionalit‰t mit dem hˆchsten Kundennutzen zu erst (Erster Durchstich / Grundsystem -> dann Funktionalit‰ten / Rapid Prototyping)
			- Web-2.0-Gesch‰ft z.B. davon Abh‰ngig, dass neue Funktionalit‰ten schnell dem User-Kreis zur Verf¸gung gestellt werden kˆnnen -> Konkurrenz zuvor kommen (WebShop / soziales Netzwerk ... ) 
			- Schnelle Ausnutzung von neuen Programmfunktionalit‰ten in Produktion -> kann wirtschaftlichen Vorteil bringen -> Markt im Web-2.0 mit viel Bewegung
				-> Bsp: Flickr / Etsy -> neue Funktionalit‰ten unverz¸glich am Markt verf¸gbar
			- Ziel nach Humble/Farley ist: n¸tzliche und funktionierende Software so schnell wie mˆglich den Nutzern verf¸gbar machen.\cite[S. 11]{CD}
		Problem 2: BugFix nicht schnell einzuspielen
			- Gegensatz einmaliger Einf¸hrungsprozess f¸r SW -> Abnahme... \cite[S. 169 ff]{steinweg04}
				-> Bsp: Banking-Software mit Einzeiler-Bug der erst Wochen nach Inbetriebnahme auff‰llt -> hoher Personalaufwand f¸r Release, n‰chstes erst in Wochen geplant -> vermeidbare Kosten mit automatisierter Lˆsung
				-> BugFix muss schnell in Produktion gehen kˆnnen -> Build-Pipeline
		Problem 3: Aufwand und Fehler von SW-Lieferung hoch
			- Einspielen einer Produktivversion mit viel Aufwand verbunden
				-> Beipsiel manuelles Deployment bei Versicherungsanwendung -> Night-Session -> Vorbereitung -> Personal
			- Manuelles vorgehen kann fehlerhaft verursachen -> Gr¸nde \cite[S. 5-7 und 9-10]{CD}
			- fehlerhaft manuelles Deployment vermeiden -> CD basiert auf Prozesse und Automatisierung	
		Problem 4: Anwender-Feedback zu sp‰t
			- Anwender erhalten erst zum Schluss die Mˆglichkeit der Einflussnahme  \cite[S. 179 ff]{steinweg04}
				-> Anitpattern: \cite[S. 7 ff]{CD}
			- Agiles Manifest schl‰gt ein direkte Kundeneinbindung in den Entwicklungsprozess mit ein \cite{manifesto}
				-> der Kunde muss fr¸hzeitig eine Ausf¸hrbare Version in der Had halten kˆnnen -> Verst‰‰ndigung von Kunde und Entwickle		
	
	2.2 Die DevOps-Bewegung:
		- Ausgehend von der belgischen Stadt Ghent, vertraute Gruppen nach agilen VM dort konentriert -> DevOps-Days (2009) \cite{cd_devops_1}
		- DevOps.com -> Slogan "Helping finish what Agile development started"
		- Chris Read: "At its heart it is the integration of Agile principles into Operations practices." -> "enabled the rise of the Cloud and Web 2.0 giants" \cite{cd_devops_stateofnation}
		- Agile VM wie XP haben Kommunikation zwischen Business und Entwicklung verbessert -> schnelles Feedback, engere Zusammenarbeit -> bessere SW entstand \cite{cd_devops_stateofnation}
		- jetzt: SW basierend auf dem feeback von Buisness -> neuer "Flaschenhals" entdeckt -> SW in Produktion \cite{cd_devops_stateofnation}
		- DevOps setzt Kommunikation in den Fokus und verschucht agilen Ansatz in Sys-Admin / IT-Betrieb zu bekommen -> Agile Techniken auch praktisch um Infrastrukturen zu managen\cite[S. 279]{CD}
		- Problem der Software-Welt: \cite{cd_devops_1}
			-> Angst bei Unternehmensf¸hrung vor ƒnderungen wenn die Anwendung erst einmal l‰uft, wegen fragiler Umgebung und b¸rokratischen Change-Management (ITIL) -> es vergeht viel Zeit bis ein neues Feature oder Bug-Fix eingef¸hrt wird
			-> Risikobehaftete Auslieferung -> keine Sicherheit, ob die Software in der geplanten Umgebung l‰uft -> Verhalten wie erwartet? H‰lt es die Last aus?
			-> Lauff‰higkeit nur auf Entwicklermaschinen bewiesen: Keine Test der Anwendung in produktiosgleicher Umgebung mit der erwarteten Last -> zu Viele Komponenten im Einsatz
			-> Bunkerdenken: Team-Splitt in Entwickler, tester, release Managers, System-Admins -> arbeiten in unterschiedlichen "Bunkern" und fire-and-forget Mentalit‰t -> Hin-und-herschieben von Problemen zwischen den "Bunkern"
			-> Humble: Generelle Aufteilung von Dev und Ops als auch durch Governace-Framework wie Cobit und ITIL, die verhindern wollen, das Entwickler zu viel schaden anrichten. \cite{devops_enterprise}
		- DevOps ist aber kein technologie-Problem, Technologie ist aber der Schl¸ssel um DevOps-Problem zu lˆsen. DevOps ist ein Business Problem \cite{edwards10}
			-> - B will Gewinn erwirtschaften und benˆtigt Buisiness Process (Dev, QA, Sequrity und Betrieb) -> jeder Beteiligt den Prozess auszuf¸llen
			-> Enabling the Business
			-> DevOps works on improving the interaction and flow across IT functions
			-> Q: "How to enable a business to react to market forces as quickly as possible"
		- Ansatz von DevOps: \cite{cd_devops_1}
			-> developers, testers, managers, DBAs, network technicians, and sysadmins m¸ssen selbses Ziel verfolgen: gute Software liefern -> "sysadmin coders" (Stephen Nelson-Smith)
			-> Entwicklung von Kommunikationsf‰higkeiten, verst‰ndnis f¸r das Gebiet auf dem SW geschrieben wird, verst‰ndnis f¸r das darunter liegende Gesch‰ft
			-> SW ist fehleranf‰llig, riskant und unvorhersehbar -> verweiss auf agiles manifest -> Weiterentwicklung mit technologischen Vorteilen durch Testen
			-> L¸cke zwischen 'Dev complete' und "live, in production, stable, making money" \cite{cd_devops_stateofnation}
			-> Typischerweise sind die Sys-Admins f¸r das ausbringen der SW verantwortlich -> haben Vorbehalte da sie die sw nicht kennen, ihr nicht vertrauen, die entwickler nicht kennen -> Erwartungshaltung gute SW zu liefern gering
			-> DevOps karaktresiert durch Leute die in verschiedenen Disziplinen zuhause sind -> Infrastruktur, Configuration, test schreiben, debugen, ausliefern -> Kommunikation herstellen kˆnnen
			-> Bewegung von Sys-Admin ausgegangen
		- Chris Read: Im Gegensatz zu CI, das klar definiert ist, ist dev-ops vage definiert und auf einfach nur ein Platzhalter um betriebsrelewandte Produkte und Dienste in Stellung zu bringen \cite{cd_devops_stateofnation}
		- Wie wird DevOps mˆglich: \cite{cd_devops_stateofnation}
			-> Auflˆsen von tief verwurzelten Funktionsstrukturen, hin zu funktions¸bergreifenden Teams mit Entwicklern, testern, Business Analysten und Investition in Prozessautomatisierung
			-> Kontinuierliche kleine ƒnderungen am System steigern die Stabilit‰t und senken das operative Risiko
			-> Agile Principien in den IT-Betrieb
			-> Alte Welt: Architekt schreibt Dokumentation -> Developer Entwickelt System, Tester git SW mit Fehlern zur¸ck, Betrieb versucht die SW zum laufen zu bringen.
			-> Verbindung zwischen Dev und Ops herstellen
			-> Lˆsungskonzept Cloud Service, vermeidet aufw‰ndige und manuelle Prozesse um Server zu Provisionieren. Warten auf Server kann negative Auswirkungen auf den dne Projektfortschritt haben
			-> Eine Person im Team mit F‰higkeiten f¸r Abnahme oder Netzwerk, aber auch Spezialisten die Richtlinien entwerfen und Rat geben.
			-> gemeinsamme Verantwortlichketien f¸r die Lieferkette -> Dev und Ops als geschlossene Einhei
			-> automatisierung und Tool-Chain als Erfolgsschl¸ssel f¸r DevOps
			-> Verweis auf Amazon Web Service als erfolgreiche Umsetzung von DevOps bei der die eigenen Entwickler schnell benˆtigte Server provisionieren kˆnnen.
		- Einf¸hrung von DevOps-Kultur und Praktiken ist eine notwendige Bedingung um CD zu erreichen.\cite{devops_enterprise}
		- CD lˆst die Probleme von DevOps ist deshalb als ein fester Bestandteil von DevOps zu sehen. CD wird ohne die Ber¸cksichtigung von DevOps nicht vollst‰ndig mˆglich sein. (Implikation f¸r adesso in Lieferstrategie!)
		- Chad Dickerson CEO bie Etsy: Designer und Produktmanager sind im Team und Entwicklen mit, Dev und Ops arbeiten eng zusammen -> Etsy erreichte dadurch in einem Monat 517 Deployments in Produktion angestoﬂen von 63 unterschiedlichen MA.
		
	2.2 Konzepte von CD
		- Feedback Prozess (Auslˆsen, Erhalten, Reaktion) \cite[S. 13 ff]{CD}
			- SW Decomposition f¸hrt zu vier Komponenten -> ausf¸hrbarer Code, Konfiguration, Ausf¸hrungsumgebung, Date
			- Verhalten der Anwendung wird von allen vier Komponenten beeinflusst -> alle m¸ssen unter Kontrolle bleiben
			- Jede ƒnderung am Code sollte zu Kompilierung und testen der Binarys f¸hren.
			- Kompilierter Code sollte in jeder Umgebung der gleiche sein -> Test / Produktion
			- Alles was zwischne Umgebungen wechselt sollte als Konfiguration gehalten werden -> ƒnderung an der Konfiguration testen
			- ƒnderung an den Daten -> Testen -> Feedback
			- Kompilierprozess zeigt das Syntax valide ist
			- Unit-Test zeigen das der Code sich wie erwartet verh‰lt
			- Test-Abdeckung und Metriken ....
			- Acceptance Test -> konform mit den gesch‰ftlichen Akeptanzkriterien / Kundenanforderungen
			- Nichtfunktioale Test zeigen Kapazit‰t, Verf¸gbarkeit, Sicherheit, ...
			- manuelles Testen -> exploratives Testen und Demonstration dem Kunden gegen¸ber
			- Automatisierung f¸hrt zu schnellem Feedback -> manuelle Prozesse h‰ngen von der verf¸gbarkeit der Mitarbeiter ab -> wann wird die Aufgabe erledigt?
			- Manuelles kompilieren, testen und deployment verschwendet Zeit kreativer Mitarbeiter -> langweilige und wenig herausragende T‰tigkeit -> tr‰gt nicht zur Problemlˆsung bei und kostet teure Ressourcen.
			- Testen ist Maschinenarbeit -> arbeiten schnell
		- Erhofter Nutzen (Team, Fehler, Streﬂ, Flexibilit‰t) \cite[S. 17 ff]{CD}
			- Self-Service f¸r Entwickler, Tester, Betrieb, Support -> Version der Software f¸r die Umgebung bestimmen
			- Erfahrung von H/F MA wartet auf ein gutes Build -> Endlose Emails werden gesendet -> Tickets geˆffnet -> ineffiziente Kommunikation -> bei verteielten Team sehr ineffizient
			- Vorteile jederzeit jede Version in die Umgebung bereitstellen zu kˆnnen:
				- Verifizieren von Verhalten gegen¸ber ‰leren Versionen durch Tester ("war das schon immer so?")
				- Support kann released Version in Umgebung deployen um Fehler zu reproduzieren
				- Betrieb kann letzte "gute" Version im Katastrophenfall wieder einspielen (kein manuelles Backup der alten Version wie bei z.B. bei Kaladent
				- Push-a-Button-Release
			- Fehlerreduzierung durch automatisches Konfigurationsmanagement: 
				- manuelles Konfigurationsmanagement ist abh‰ngig von F‰higkeit und Sorgf‰ltigkeit des Einzelnen in periodisch wiederholenden Aufgaben.
				- Probleme durch unterschiedliche Konfiguration der Systeme Test / Prod: nicht reproduzierbare Fehler
				- Typo schwer zu entdecken, Versionsmanagement bietet die Mˆglichkeit ƒnderungen zu tracken
				- Stand der 3rd-Party Bibliothken, Laufzeitumgebung, Server-Version, Properties f¸r Konfiguration mit unterschiedlichen Werten
				- Konfiguratiosdatein, Datenbank-Skripte und Schemas, Build-Skripte, Tests, Entwicklungsumgebungen, Konfiguration von OS
			- Stressvermeidung
				- "just get something working" vor einem geplanten Release, hoher Druck 
					-> Alternative: Release nur mit einem Button in wenigen Minuten getan
					-> Zur¸cksetzen mit automatierung genauso einfach
					-> H‰uffiges Release so einfacher, Delta zwischen aktueller und neuer Version klein
			- Deployment Flexibilit‰t
				- Ziel: Neue Umgebung mit eine paar Konfiguratiosanpassungen einrichten
				- Flexibilit‰t kommt durch die Platzierung der Software, wo immer diese benˆtit wird -> flexible Provisionierung
		- Release-Kandidat (RC) \cite[S. 22]{CD}
			- ƒnderung im Code f¸hrt mˆglicher Weise zu einer releasf‰higen Software
			- Jede ƒnderung muss validiert werde -> Build, Deployment, Test-Prozess entscheiden
			- RC = es sind keine Fehler gefunden worden & die Akzeptanzkriterien des Kunden werden erf¸llt
			- Traditionelles Release: Werkabnahme, Pilotbetrieb, Abnhame, Roll-out / Training, going live \cite[S. 172 f]{steinweg04}
			- nach HF kein Bedarf f¸r manuelles Testen wenn umfassende automatisierte Test und autom. Deployment
			- nach HF f¸hrt das Testen im Anschluss an den Entwicklungsprozess zu einer deutlichen absenkung der Qualit‰t -> f¸r Bug-Fixing keine Zeit mehr wenn Release vor der T¸r steht
			- HF f¸hren an: Entwickler vergessen was sie gemacht haben als sie den Fehler eingebaut haben -> Funktioalit‰t hat sich in der Zwischenzeit ge‰ndert -> Sp‰te Fehlersuche aufw‰ndig
			- jede ƒnderung f¸gt einen Wert hinzu -> verbessert das System an dem gearbeitet wird 
			- Im Gegensatz kann aber jede ƒnderung Fehler in ein schon laufendes System bringen -> ¸berpr¸fung setzt ausf¸hren der Software vorraus -> Integration notwendig
			- integration unvorhersehbarer schwer zu managender Prozess -> deshalb gerne nach hinten verschoben
			- Jede ƒnderung sollte den Prozess von bauen und testen anstoﬂen -> CI-System
		- wiederholbarer, verl‰sslicher Prozess -> automatisierung  (Prinzip der Softwarelieferung)\cite[S. 24]{CD}
			- Prinzipien nach HF: 
				- wiederholbarer & verl‰sslicher Prozess
					- Einfachheit Software zu liefern -> wenn gut getestet
					- Ein-Knopf-Lˆsung
					- setzt auotmatisierung und versionskontrolle von build, deploy, test und release vorraus
					- Deploying setzt vorraus: provisionierung und managen von umgebung in der sw l‰uft, istallation der richtigen version, konfiguration mit richtig daten oder zustand
				- vollst‰ndige automatisierung
					- automatisierter deployment / sw release Prozess
					- akzeptanz test
					- Datenbank installation und konfiguration
					- nicht automatisiert werden kˆnnen: exploratives testen, demonstrationen, compliance -> menschliche interaktion
					- am anfang einfache es manuell zu tun -> beim 10. Mal aber nicht mehr -> Aufwand und Fehler!
				- alles in Versionskontrolle
					- alles f¸r build, deploy, test, release -> in versions kontrolle
					- Anforderungsdokumente, test-skripte, autom. test-f‰lle, netzwerk-config-skripte, deployment-skript, datenbank-creation, upgrade, downgrade, initialisierungs-skripte, libs, toolchain, technische-doku
				- Qualit‰t
					- f¸rhes erkennen von Fehlern senkt die Kosten die zu beseitigen
					- ci, automatisiertes testen, autom. deployment -> helfen fehler fr¸h wie mˆglich im Prozess zu erkennen
					- erfodert Disziplin, Fehler dann unverz¸glich zu beseitigen -> Testen ist keine Phase am Ende des Entwicklungsprozesses
					- Teste ist keien Domaine der Tester -> Jeder ist f¸r die Qualit‰t verantwortlich -> (Woher: Manifesto / XP?)
				- Def of Done
					- HF denken, feature erst Fertig, wenn es dem Nutzer einen Wert bringt -> nicht immer praktikabel, da es l‰ngere Zeit dauern kann bis externe Nutzer einen Nutze haben
					- Deshalb: DOD -> erforlgreich vorgef¸hrt, demonstriert und ausprobiert durch eine Repr‰sentanten der Nutzergruppe in eine Produktions-‰hnlichen Umgebung
					- nicht 80%-fertig eher -> noch 3 PT Arbeit oder ‰hnliches
					- keine Einzelner sondern eine Team von testern, it-betrieb, support, entwickler m¸ssen f¸r "done" zusammenarbeiten
				- Verantwortlichkeit
					- Gemeinsamme Verantwortung f¸r den Lieferprozess -> Sollte Ziel der Organisation sein
					- In kleinen Teams / Organisationen besteht h‰ufig vollst‰ndige Kontrolle ¸ber die benˆtigten Ressourcen
					- Groﬂe Orgaisationen mˆglicherweise isolierende Barrieren zwischen Rollen und Leuten -> Entwicklerr - Tester - Ping Pong
					- Mˆglichkeit schaffen f¸r eine einfachen Kommunikation zwischen Leuten
					- System f¸r Status der Software -> Zustand, kompilierte Pakete, welche Tests, zustand der Umgebungen
					- System sollte die Mˆglichkeit bereitstellen den einzelnen die Arbeit zu erleichtern -> Self-Service Deplyoment f¸r Tester etc.
					-> DevOps-Bewegung: Zusammenarbeit zwischen den Beteiligten im SW-Lieferprozess fˆrdern
				- Continuous Improvement
					
	2.4 Exkurs - ITIL, DevOps und CD:
		- ITIL ist ein Prozessstandard f¸r IT-Service-Management, welches vom Office of Government Commerce herausgegeben wird \cite{itil_boetcher}
		- Bedeutung f¸r CD hat das Change- und Release Management aus dem ITIL-Buch Service Transition, welches Prozesse und Verfahren beschreibt -> neue / ge‰nderte IT-Services in den operativen Betrieb zu heben.
		- ITIL Service Transitions wird von Service-Design angestoﬂen und m¸ndet in Service Operation \cite[S. 81 ff]{itil_boetcher}
		- Service Transition Kernprozesse: Transition Planning und Support, Change Management, Service Asset & Configuration Management, Release & Deployment Management
		- ITIL Change- und Release Management hat synergienm mit DevOps -> Implikationen f¸r CD \cite{DevOpsITIL}
		- Ziel ist Schutz und Erhalt der Systemintegrit‰t der bestehden Infrastruktur \cite[S. 108 ff]{itil_boetcher}
		- unvorhergesehene Beeintr‰chtigungen bei der Einf¸hrung neuer / ge‰nderter Dienste zu vermeiden
		- ITIL hat R¸ckhalt in grˆﬂeren Organisationen mit etablierten Teams f¸r den IT-Betrieb und mit einer risikoscheuen Haltung. DevOps eher bei StartUps zu finden.  \cite{DevOpsITIL}
		- Change Management: Ablaufsteuerung von Ver‰derungsmaﬂnahmen \cite[S. 89 ff]{itil_boetcher}
		- Aktivit‰ten: erstellen und Dok von RFC, Zulassen und Beurteilen von RFC, Autorisieren, Koordinieren der Implementierung, Pr¸fen des Ergebnisses.
		- Release-Management
		- Aktivit‰ten: Release-Richtlinien, Planen von Release, Erstellen und Testen von Release, Implementieren von R, Support bei Einf¸hrung, Abschlieﬂen von Release-Projekt
		- Als Methoden wird die Trennung von Entwicklungs-, Test,- und Produktivumgebung empfohlen sowie die nutzung von SW-Verteilungstools
		- Unterschieden werden im Release-Management: Major R., Minor R. und Emergency Fix
		- ITIL Release-Richtlinien in Richtung CD -> automatische SW-Verteilung, Sequentielles Roll-Out, Push
		- Verifizierung von Releases in einer 1zu1 Abildung der Produktivumgebung durch Testverfahren \cite[S. 114]{itil_boetcher}
		- ITIL Release-Management verlangt Fehleridentifikation, Ursachenanalyse, Fehlerbeseitigung + funktionale und operationales Testen nach entworfenen Testkonzepten
			-> Installierbarkeit, Integration in bestehende Infrastruktur, auswirkung auf Systemstabilit‰t und Leistungsverhalten
			-> Funktionalit‰tstests ob erwartetes Verhalten auch tats‰chlich auftritt
			-> Know-How Transfer von Dev auf Release-Manager
		- Validierung von SW in operativer Umgebung mit kleinem Anwenderkrei -> strukturierter Feedback-Prozess
		- Release Aktivit‰ten, die CD ber¸hren (typisch): Logistik, Paketierung und Distribution auf Depot-Server, Verteilung auf Zielrechner, Konfiguratiosmanagement
		- chronologische Dokumentation aller ƒnderungen mit Versionskontrolle (SVN)
		- nach Humble: ITIL Prinzipien und Praktiken in einer leichtgewichtigen Art verfolgen und die Ziele eines effektiven Service Management erreichen durch schnelles und verl‰sslichen Lieferprozess \cite{itil_cd}
		- CD reduziert Risiko der ƒnderung durch regul‰res ausf¸hren von Realeases
		-> Anforderung ist aber das Ops und Dev eng und fr¸h im Projekt zusammen arbeiten, automatisierte Prozesse, Provisionierung von Produktions- und Testumgebung
		-> Deployment-Pipeline unterst¸tzt Change-Management effektiv, da Lieferprozess kontrolliert wird -> Revisions und compliance tool wenn folgendes auf das verwendete Tool zutrifft:
			-> Welche Version ist aktuell in welcher Umgebung deployt?
			-> Durch welche Teile der Pipeline ist welche Version durch, mit welchem Ergebnis?
			-> Wer hat das Build, Test und Deploymetn ausgelˆst?
			-> Zur¸ckverfolgung von Deployment zur¸ck zur Vreison im SVN
			-> Prozess-Metriken wie Durchlaufzeit
		-> CD ist effektiver Weg f¸r leichtgewichtiges Mechanismen des ITIL Change-Prozesses durch etabliertes und h‰ufig genutzten Change Prozess.
		- Kontinuierliches Monitoring und Feedback
		- nach Minick Release Manager nat¸rliche DevOps-Vermittler
			
	2.5 Rechtlich und vertragliche Implekationen von CD:
	
	2.6 Zusammenfassung
		- DevOps und CD fokusieren stark Web-Technologien
		- DevOps zielt auf die Kommunikationsprolblematik zwischen Entwicklung und IT-Betrieb 
			-> DevOps schl‰gt st‰rkere Einbindung von IT-Betrieb in Dev vor 
			-> Know-How-Mix in den Teams notwendig 
			-> Dev soll selbst Infrastruktur provisionieren kˆnnen 
			-> Produktions und Testumgebung identisch (Setup / System)
		- CD stellt klaren Prozess mit Vorgaben zu Automatisierung / Konfigurationsmanagement / Qualit‰t / Def of Done / Verantwortlichkeiten bereit.
		- CD unterst¸tzt ITIL Change und Release Management, wenn ITIL in leichtgewichtiger Art und Weise betrieben wird.

Deployment Pipeline und Liefersystem
	
	Einleitung:
		- Bezug zu DevOps: DevOps kann die Deployment-Pipeline als Realisierung eines Liefersystems betrachtet werden
			-> Deployment-Pipeline bildet den Prozess auf ein Liefersystems ab
		- Bezug zu untersuchenden Werkzeugen: Soll den Kontext der Werkzeuge zeigen und Vergleich zum derzeitigen Lieferprozess ermˆglichen
			-> speziell Werkzeuge: welche Konzepte von CD und der DP werden verwirklicht -> Welche Anforderungen aus CD kˆnnen damit umgesetzt werden.
			-> speziell adesso-Lieferprozess: Welche Konzepte werden derzeit umgesetzt, was wird f¸r das Liefersystem vorgeschlagen
		- Deployment-Pipeline untersucht den Aufbau -> Build und Deployment-Skripting f¸r Automatisierung
			- automatisches Deployment in die Produktivumgebung erfordert Erf¸llung aller aktzeptanz Kriterien, funktional als auch nicht funktional
			- manuelle Test sind aufw‰ndig und Kostenintensiv, Exploratives Testen ist aber nur manuell mˆglich
		- Liefersystem befasst sich mit Infrastruktur und Umgebung die CD ermˆglicht / Untersuchung von Problemstellung aus Datenbanken, wenn automatisiert ausgeleifert wird / Umgang mit neuen noch nicht vollst‰ndigen Funktionalit‰ten / Konflikte durch Versionsmanagement vermeiden
			- Um Test in Produktivumgebung ‰hnlicher Umgebung durchzuf¸hren ist schnelle proivisionierung von Infrastruktur notwendig und Verteilung der RC, in der (Web-)Produktivumgebung muss die Aktualisierung der 
				-> Liefersystem muss durchdacht und geplant sein
				
	Deployment Pipeline nach HF:
		DP-Einleitung:
			- Deployment-Pipeline ist Grundkonzept des Liefersystems, welches auf CI aufbaut.
				- Exkurs CI:
					Features von CI nach Duvall:
						- Fr¸here Problemidentifizierung durch CI \cite[S. 6]{Duvall07}
							- arbeiten alle Softwarekomponenten zusammen
							- Wie komplex ist der Quellcode
							- Werdem im Tema Coding standards umgesetzt
							- Wie hoch ist die Testabdeckung
							- Alle Tests auch nach letzten ƒnderung erfolgreich
							- Werden die Kapazit‰tsanforderungen erf¸llt
							- Funktionierte das letzte Deployment
						- "Build Software at Every Change" \cite[S. 4]{Duvall07}
							- 
						- CI-Szenario \cite[S. 5]{Duvall07}
							-> Abbildung in \cite[S. 5]{Duvall07}
				- fr¸he und kontinuierliche Integration der Software gibt schnelles und fr¸hes Feedback, ob alle Komponenten in sp‰terer Produktionsumgebung zusammenspielen 
				- Abrenzung zu CI: -> CD = CI + automatisierte Akeptanztests + Deployment in Produktion  \cite[S. 105]{CD}
				-> Grafik von Schlegel: Javamagazin: CD-CI
			- CI nicht genug:
				- HF sehen, CI ist nicht genug da nur auf Dev-Teams fokussiert -> Output von CI ist Input f¸r manuelles Testen und den Rest des Release-Systems  \cite[S. 105]{CD}				
		Ziele der DP:
			Problembeschreibung:
				- Verschwendung in Release-System durch: \cite[S. 105]{CD}
					- Dokumente oder Fixes auf die Build / Ops warten
					- Tester warten auf gute "Builds" 
					- Dev erh‰lt Bug-Reports wochen nach dem schon zu neuen Funktionalit‰ten ¸bergegangen wird
					- Entdeckung am Ende des Dev-Prozesses, das die Architektur nicht die nicht-funktionalen Anforderungen erf¸llt
				-> erhˆht die Gefahr von fehlerhafter Software durch lange Feedback-Zyklen zwischen Dev - Test und Ops
				- Problem des Release: bei Scheitern, Business muss auf neue Funktionalit‰ten warten oder kritische Betriebsressourcen sind gestˆrt. Lˆsung:
					- Release Plan bei dem jeder zugriff hat
					- maximale Automatisierung / minimale fehlerbehaftete manuelle Eingriffe
					- routiniertes Training in Produktions-‰hnlicher Umgebung
					- Mˆglichkeit des Zur¸ckgehensm wenn etwas schief geht
					- Strategie, Konfiguration und Produktions-Daten als Teil des Updates / Rollback \cite[S. 129]{CD}
			Lˆsungsansatz nach HF:
				Technisch.- organisatorische Lˆsung:
					- HF schlagen eine automatisierte DP vor -> da automatische Manifestierung des Lieferprozesses
					- Entwicklung eines Modells, um Software vom Check-In zum Release zu bekommen -> "Concept to Cash" (Wertstromanalyse des Lieferprozesses)
					- Neu Form der Zusammenarbeit wird benˆtigt: 
					- Deployment Pipeline kann nur durch gute Zusammenarbeit zwischen den beteiligten Individuen entstehen
				Prozessvorschlag:
					- das Build durchl‰uft die Pipeline bis zum Release mehrfach -> in Stufen: 
						- Delivery Team
						- Version Control
						- Build & Test
						- Automated Acceptance Test
						- User Acceptance Test
						- Release
					- Grafik -> Sequenzdiagramm \cite[S. 109]{CD}
					- automatisierung der Teilschritte durch Skripte und Tool-Chain
						-> Fundamental: eine automatisierter Softwarelieferprozess schlieﬂt menschliche Handlung nicht aus, 
							-> stellt sicher das fehleranf‰llige und komplexe schritte automatisiert, wiederholbar und verl‰sslich sind!					
				Vorteile:
					- HF sehen in dieser Strategie folgende Vorteile:
						- effektiv wenn nur gr¸ndlich getestet SW in Produktion geliefert wird -> Test bei jedem Durchlauf der Deployment-Pipeline
							- wird nur durch Reihe von automatisierten Akzeptanztests mˆglich
						- Ein derartiger Process ist schnell, wiederholbar und verl‰sslich
						- auch dringende Bugfixes durchlaufen den gleichen Prozess und werden auf gleiche Weise getestet wie normales Release
						- Disziplin der Deployment Pipeline schw‰cht Fehler ab, die durch neue Konfiguration oder unvorhersehbare Interaktion der beteiligen Komponenten der Systemumgebung entstehen kˆnnen
		Struktur der DP:
			- Grafik -> Basic deployment pipeline \cite[S. 111]{CD}
			- Pipeline kann in Stages untergliedert werden, Einheiten im Lieferprozess: Commit-Stage, Autom. Akzeptance Stage, Man- test-Stage, Release-Stage \cite[S. 109-110]{CD}
				-> Commit Stage: 
					-> Prozess von CI
					- stellt sicher, das das System auf dem technischen Niveau arbeitet -> es kompiliert, Komponententests sind erfolgreich und Code-Analyse ist erfolgreich
					- beginnt mit Commit von ƒnderungen die ein Entwickler am Quellcode vorgenommen hat -> Versionskontrollsystem
					- CI-System reagiert mit neuer Instanz des Softwarelieferprozesses -> Laufzeit sollte 5-10 Minuten (ideal) -> Paralellisierung \cite[S. 105-120]{CD}
					- Schritte: Kompilieren / Commit-Test (Komponententests) / Bin‰rdaten erzeugen / statische Codeanalyse (White-Box) / Artefakte wie Testdantebank erstellen \cite[S. 120]{CD}
					- Metriken: Testabdeckung / Kodedubletten / Zyklomatische Komplexit‰t / Afferente und efferente Kopplung / Anzahl von Warnungen / Code Style \cite[S. 121]{CD}
						-> Testabdeckung: Tools wie Sonar berechnen die Abdeckung von Code-zeilen, die von einem Test abgedeckt werden. \cite{sonar_testcoverage}
						-> Zyklomatische Zahl misst die strukturelle Komplexit‰t des Quellcodes an hand des Kontrollflussgraphen und gibt die menge unabh‰ngiger Pfade im Programmfluss an. Wird jeder Pfade des Kontrollflussgraphen einmal durchlaufen, ergibt sich eine Abdeckung von 100 % \cite[S. 100 f]{sl_basiswissen_sw_test}
						-> afferrente Kopplung beschreibt die Anzahl der Klassen auﬂerhalb eines Paketes, die von Klassen innerhalb des Paktes abh‰ngen (incomming), efferente Kopplung hingegen ist die Anzalh von Klassen auﬂerhalb eines Paketes von denen Klassen innerhalb des Paketes abh‰ngen (outgoing). Beschreibung f¸r stabilit‰t -> I = Ce / Ca + Ce -> Range [0,1] 0 ist stabil. \cite[S. 23-24]{martin_design_principles}
!						-> Warnungen und Code-Style sind nicht beseitigte Schwachstellen -> Java Code Conventions, welche Sun folgt und empfiehlt -> filenmaes, file-organisation, Einr¸ckung, Kommentatare, Declarationen, Namensvergabe \cite{java_code_conv}
					- CI-System speichert Artefakte in einem Repository oder es kˆnnen Systeme wie Nexus oder Artifactory genutzt werden -> Links zu Nexus und Artifactory
					- Bin‰rdateien einer Version nur einmal kompilieren -> wird in allen Stages (Test etc.) benˆtigt -> mehrfaches Erstellen nicht empfohlen weil: \cite[S. 113]{CD}
						- kosten Zeit und ist deshalb nich effektiv
						- Bin‰rdaten die in Produktion geliefert werden, sollten exakt identisch mit denen des Akzeptanztests sein.
						-> Gefahr, dass ƒnderungen w‰hrend der Pipeline an der Quellcodebasis vorgenommen werden -> Dann unterschied zwischen getesteter und in Produktion released (Revisionssicherheit)
						-> Konfigurationsmanagement notwendig, da Bin‰rdateien nicht f¸r eine bestimmte Umgebung erstellt werden kˆnnen -> felxibilit‰t und wartbarkeit werden reduziert
				-> Automated Acceptance test stages:
					-> Pr¸ft ob eine Anwendung in Produktion gehen kann -> RC?
					- Akzeptanztests: werden Kundenanforderungen erf¸llt, ist die Spezifikation erf¸llt, kann die Anwendung in Produktion deployt werden? \cite[S. 124]{CD}
					- System erf¸llt funktionale und nicht-funktionale Anforderungen, Verhalten erf¸llt die Bed¸rfnisse des Nutzers und die Spezifikation des Auftraggebers 
						-> Nichtfunktionale Tests: Kapazit‰t / Sicherheit / Service-Level-Agreement \cite[S. 128]{CD}			
					- Regressionstest das keine Fehler sich in bestehendes Verhalten geschlichen haben \cite[S. 124]{CD}
					- Produktionsumgebung wenn komplex und teuer -> kleiner skallierte Version nutzen (kleine Anzahl von Middleware-Server)
					- Verhalten: schl‰gt eine Pipeline fehl, sollte dies unverz¸glich behoben werden -> Verantwortung beim ganzen Team \cite[S. 125]{CD}
					- Fail bedeutet -> nicht f‰hig ausgeliefert zu werden \cite[S. 126]{CD}
					- l‰ngerlaufende Akzeptanztests -> Aufteilung in Suits (User Akzeptanz / Kapazit‰t) f¸r parallele Ausf¸hrung
				-> Manuell test stages: 
					- Das System ist bedienbar und erf¸llt die Anforderungen. Hier werden Fehler aufgedeckt, die nicht durch automatisierte Tests abgedeckt werden kˆnnen - Verifiziert, das Wert f¸r den Anwender produziert wurde
					- Tester pr¸fen ob Akzeptanztests das Verhalten des Systems testen durch Validierung der Akzeptanzkriterien \cite[S. 128]{CD}
				-> Release stage / Deployment: 
					- Liefert das System aus (Paket oder Deployment in Staging / Produktivumgebung
					- Deployment muss auch Test-Systeme ber¸cksichtigen \cite[S. 126]{CD}
					- Ansicht was aktuelle deployt ist! \cite[S. 126]{CD}
					- Visualisierung / Berichte / Autorisierung \cite[S. 126]{CD}
					- -> eigenes System: liste mit release-Kandidaten / Button zum deployen f¸r Version und Umgebung der Wahl \cite[S. 126]{CD}
					- SSP f¸r Tester, die eine bestimmte Version zum testen w‰hlen kˆnnen. \cite[S. 126]{CD}
				-> Zus‰tzliche Stages je nach Art des Lieferprozesses, m¸ssen hinzugef¸gt werden			
		Ablaufsteuerung:
			- Gleiches Skript f¸r Deployment, unterschiedliche Umgebungseinstellungen kˆnnen Properties Files / Datenbanken / LDAP gehalten werden \cite[S. 115-116]{CD} 		
			- Pipeline-Trigger: \cite[S. 118-119]{CD}
				- SVN-Check-In -> erfolgreiche Stage triggert die n‰chste
				- Bsp: Build-Stage triggert Akzeptanz-Stage -> SVN-Ckeck-in einer neuen Version -> Build der jeweils neusten Version, Check-Ins dazwischen sollten ignoriert werden, wenn Akzeptanz-Stage fertig, neustes Build testen ....
			- Building on success / Bedingungen f¸r den RC \cite[S. 132]{CD}
				- Code kompiliert
				- Code macht das was der Entwickler denkt, was er machen sollte (Unit-Test)
				- System macht, was die Analysten / Nutzer denken, was es sollte (Akzeptanztests)
				- Konfiguration und Infrastruktur wird gemanaged / analog zur Produktivumgebung
				- Alle Komponenten am Platz, da deployt werden konnte
				- Deployment System selbst arbeitet -> da es bei Entwicklungsumgebung / Akzeptanzumgebung / Testumgebung f¸r Deployment schon angewandt wurde
				- Versionskontrolle h‰llt alles f¸r das Deployment bereit, ohne manuelle eingriffe -> System wurde bereits mehrfach deployt
			- Nach Deployment Smoke-Test, der pr¸ft ob die Anwendung l‰uft, sowie jeder abh‰ngige Dienst (z.B. Datenbank) \cite[S. 117]{CD}
		Vorraussetzungen f¸r DP:
			- Planung:
			- Vorgehensweise bei der Erstellung der Pipeline \cite[S. 133]{CD}
				- Wertstromanalyse des Prozesses + lauff‰higes Skelett
					- Schritte niederschreiben mit Stift und Papier die im Prozess derzeit ablaufen
					- Stage f¸r Stage konstruieren (Commit-Stage mit Test / Akzeptance-Stage / ...)
					- Neues Projekt -> lauff‰higes Skelett mit Hello World (am besten vor der eigentlichen Arbeit)
				- Build + Deployment-Prozess automatisieren
					- Quellcode als Input -> Bin‰rdatein als Output
					- jedes Mal nach Check-In -> CI-System
					- Deployen nach UAT env + Push-Button Deployment in Umgebung -> f¸r jedes Build der Applikation (von CI) + Deplyoment-Test (Smoke)
				- Autom. Unit-Tests + Code-Analyse \cite[S. 135]{CD}
					- Teil der Commit-Stage
					- benˆtigen kein komplexes Set-Up / benˆtigen keine laufende Instanz der Anwendung
					- Laufzeit > 5 Minuten -> Aufsplitten in paralell laufende Suites
				- Autom. Akzeptanz-Tests
					- Akzeptance-Test-Framework Start-up -> Reports einsammeln am Ende des Durchlaufs
					- funktionale / nicht funktionale Anfordeurngen
				- Autom. Release auf Produktion
				- Komplexe Anwendungen / Komponenten
					- komplexe Anwendungen in kleinen eigenen Pipelines bauen und testen
					- alles zusammenf¸gen und Komplettsystem testen
				-> inkrementell implementieren
				-> Daten sammeln, wann gestarten, wann welche stage ... -> auswertung
				-> Pipeline ist eine "lebendes System" und muss stetig weiterentwickelt und angepasst werden \cite[S. 137]{CD}
			- Infrastruktur:
				- Test ~= Produktion: netzwerk-Topologie / firewall, OS + patchen, App-Stack, Applikationsdaten
			- Organisation:
				- Automatisiertes Deployment: Problem h‰ufig da nicht ausreichende Kontrolle ¸ber Produktionssystem \cite[S. 129]{CD}
					-> Alle ƒnderungen am System sollten automatisiert erfolgen (Konfiguration / SW-Stack / Netzwerk-Topologie / State)
					-> Probleme lassen sich schnell verfolgen / Konfigurationen zur¸cksetzen ... (bei Skripte + SVN) -> bessere Wartbarkeit
		Exk.: Build und Deployment Skripting:
			- Ermˆglicht die Pipeline und ist Grundtechnik um Binaries zu erstellen 
				-> auch unterst¸tzung zur Auslieferung auf die Zielplattform vorhanden.
			- "Skript" als weiter Bereich der Automatisierung von Aufgaben gemeint
			- Build-Tool - Aufgabe: Netzwerk von Abh‰ngigkeiten modelieren
			- Verschiedene Tools am Markt, im Java-Umfeld Ant und Maven \cite[S. 147-149]{CD}
				- ant \cite[S. 147-148]{CD}
					- Task-orientiert
					- XML als DSL zur def von Tasks
					- Kompilierung / Filesystem-Tasks
					- cross-plattform Kompatibel
				- maven \cite[S. 149-]{CD}
					- onvention over configuration -> Projektstruktur durch Maven vorgegeben
					- automatisches Management von Java libs
					-> Maven Autoupdate kann Build-fehler verursachen -> unvorhersehbar  -> mglw. nicht reproduzierbare Build!
			- Prinzipien:
				- Je Stage eine Build-Skript
					-> dem Domain-Driven-Design entlehnt \cite[S. 152]{CD}
					-> Deployment-Pipeline hat organisationsprinzip um Verantwortlichkeiten zwischen Build-Skripts aufzuteilen
				- Erfordert Zusammenarbeit von Entwicklern und IT-Betrieb -> DevOps
				- OS-Spezifisches Packetierungs-Werkzeug nutzen, da dann Tools wie Puppet genutzt werden kˆnnen, um Pakete zu verteilen:
				- ....
				- Zur¸ckverfolgung von deployten Bin‰rdaten zur Versionsnummer der Versionsverwaltung \cite[S. 165]{CD}
				- Bin‰rdatein sollten nicht in das Versionsverwaltungssystem eingecheckt werden \cite[S. 166]{CD}
					-> steht in Konflikt mit Nummernsystem der Versionsverwaltung
					-> geteiltes Dateisystem (e.g. Netzlaufwerk / FTP ...) um Bin‰rdatein und Berichte zu verwalten
			- Schritte:
				- Umgebung einrichten: Script muss h‰ufig auf verschiedenen Systemen laufen
					-> Datenbank upgraden, neue Bin‰rdatei deployen, Dienst von dem die Anwendung abh‰ngt aktualisieren \cite[S. 161]{CD}
					-> Software-Layer muss beachtet werden (Hardware - OS - Middleware - App / Service / Komponenten + jeweilige Konfiguration) \cite[S. 162]{CD}
					-> nach HF drei Mˆglichkeiten: \cite[S. 161]{CD}
						- Skript, welches sich auf die Systeme einloggt und ƒnderungen durchf¸hrt 
						- Lokales Skript, wird durch Agents auf allen Systemen ausgef¸hrt
						- Package der genutzten Platform bauen + Infrastruktur-Management-Tool das die ƒnderungen ¸bernimmt (besste Option)

	Implikationen f¸r das Liefersystem:
		- Liefersystem besteht aus Infrastruktur und Umgebungen
		- besonderer Fokus auf Datenbanken, Abh‰ngigkeiten und Versionsverwaltung
			- Anwendung in der Deployment-Pipeline benˆtigt Daten-Management -> Datenbanken m¸ssen f¸r neue Funktionalit‰ten vorbereitet werden
			- Anwendung h‰ngt von weiteren Komponenten / Bibliotheken ab -> Abh‰ngigkeiten m¸ssen vor Auslieferung organisiert werden
			- Im Versionsverwaltungssystem kˆnnen Probleme durch Branching und Merging entstehen
		Schnittpunkte von CD bei IT-Infrastruktur und Systemumgebungen:
			- Auswirkungen auf den IT-Betrieb:
				- in mittleren und grˆﬂeren Unternehmen ist IT-Betrieb eigene Organisationeinheit
				- Dokumentation und Betriebsp¸rfung / Revision 
					- nach ITIL ist deployen von ƒnderungen in Umgebung ein Prozess nach Change-Management \cite[S. 89 ff]{itil_boetcher}
					- Erfordert Dokumentation von RFCs, diese m¸ssen beurteilt, auf Risiken gepr¸ft und authorisiert werden
					- Dev-Team muss sich auf Situation einstellen und den Prozess rechtzeitig mit Ops durchgehen  \cite[S. 182]{CD}
					- sollte deshalb zum release-plan gehˆren
				- Alarme
					- Monitoring-Systeme werden duch Ops verwendet um die Infrastruktur zu ¸berwachen
					- Dev muss Systeme vor Entwicklung kennen und die integration in diese ber¸cksichtigen und planen  \cite[S. 182]{CD}
					- Wo sind Log-Files und wie wird auf Fehlverhalten aufwerksam gemacht
					- Ziel ist die f‰higkeit Ops die Anwendung neu deployen / neu starten zu lassen
				- es sollten nur Technologien verwendet werden, die vom IT-Betrieb beherrscht werden
					- Planung aus Dev zu beginn der Entwicklung heraus, wie deployt werden soll  \cite[S. 282]{CD}
					- Vereinbarung (Dev-Ops) ¸ber verwendete Skript- / Paket-Technologie  notwendig [Ruby, Perl, Python, Debian-Package, ...]  \cite[S. 283]{CD}
			- Auswirkungen auf das Management der Infrastruktur:
				- Infrastruktur ber¸hrt die Domaine des IT-Betriebs, muss modeliert und verwaltet werden
				- Verbundene Fragestellungen:  \cite[S. 284]{CD}
					- Wie wird provisioniert?
						- Innerhalb der Deployment-Pipeline notwendigkeit Server flexibel provisionieren zu  kˆnnen, z.B. um automatisierte Test parallel durchf¸hren zu kˆnnen	
					- Wie wird deployt und konfiguriert?
						- Middelware (z.B. f¸r verteielte Systeme [Application-Server, RMI, ...]) muss dann konfiguriert werden
					- Wie wird die Infrastruktur verwaltet?
						- Zugriffskontrolle zur Infrastruktur um ƒnderungen durchf¸hren zu kˆnnen
				Lˆsungsvorschlag von HF:
					- Provisionierung von Infrastruktur:
						- Abhilfe: Nutzung von Virtualisierung und Cloud-Computing f¸r Provisionierung von Servern, bzw. zum starten von vorkonfigurierter Systeme
						- Keine ƒnderung am System ohne vorherige Zustimmung (von wem?)
						- automatisierte Prozesse um ƒnderungen an der Infrastruktur vorzunehmen (SVN-Check-In)
						- Deployment-Pipeline sollte vor Deployment testen, ob die Anforderungen an die Infrastruktur getroffen worden sind
						- Testumgebung f¸r ƒnderungen an der Infrastruktur \cite[S. 287]{CD}
						- Problem, wenn Infrastruktur mit anderen Systemen geteilt wird. -> keine Ver‰nderung der Konfiguration mˆglich ohne Seiteneffekte auf anderes System
						- Server-Provisionierung und Konfiguration Managen
							- Infrstrukturdienste nutzen? Virtualisierung?
							- Wie werden Server provisioniert -> Technik
							- Betrieb und Verwaltung der Server
					- Konfiguration von Middelware:
						- Nach Mˆglichkeit sollte Konfiguration per Skript f¸r OS und Middleware in Versions-Verwaltung hinerlegt sein  \cite[S. 285]{CD}
						- Middelware Konfigurieren
							- Konfigurationen verwalten
							- Produkte m¸ssen daf¸r untersucht werden
							- Wie werden Zust‰nde in der Middleware gesteuert -> kˆnnen diese beeinflusst werden?
							- Konfigurations-API, die die Configuration programmatisch ¸bernimmt?,
					- Monitoring:
						- Infrastruktur ¸berwachen -> ƒnderungen ¸berpr¸fen -> ƒnderungsverlauf ¸berpr¸fen
							- Daten sammeln
							- Logging
							- Instrumentenpult erstellen, die den Zustand und das Verhalten der Applikation anzeigt
		Kritische Komponenten in der DP:
			Datenbankupdate in der DP:
				- Datenbank als kritische Komponente w‰hrend des SW-releases
					- z.B. Neue Funktionalit‰t in Web-Anwendung soll Deployt werden, die eine ƒnderungen an einer Tabelle erfordern
					- Problem z.B. bei inkrementelles Update einer Web-Anwendung, die unterschiedliche DB-Versionen nutzen
						-> Was passiert mit Nutzertransaktionen auf alter DB-Version
						-> Anwendung kann nicht live gehen, wenn dies nicht gekl‰rt.
					- Datenverlust duch Release vermeiden
						- Fehlschlag beim Release -> Rollback der DB schnell, einfach und automatisiert?
					- Vorbereitung und Organisation von Persistenz auf der die Anwendung arbeitet
				- Lˆsungsmˆglichkeiten:
					- Inkrementelle ƒndeurngen an Datenbanken
						- Zu beginn aufsetzen der Datenbank
						- Wenn neue Tabellen benˆtigt werden, kˆnnen z.B. "ALTER TABLE" Anweisungen ausgef¸hrt werden
						- Im Skript m¸ssen auch UNDO-Operationen vorgesehen werden, um die ƒnderungen r¸ckg‰ngig zu machen
						- Versionierung: Notwendig im Skripte zu ermitteln ob Skripte ausgef¸hrt werden kˆnnen.
						-> Tool, welches den aktuellen Stand der Datenbank ¸berpr¸ft und das x+1-Skript ausf¸hren kann. (Tool:DbDeploy) \cite[S. 328]{CD}
					- Datenbank-Rollback
						- Datenbanken + Anwendung zur¸cksetzen kˆnnen, wenn beim Deployment etwas schief geht: \cite[S. 332]{CD} (Blue-Green-Deployment)
							1. Datenbank-Backup erstellen und auf zweiten DB-Server einspielen (z.B. durch Provisionierung)
							2. ƒnderungen an der Datenbank vornehmen und Funktion testen (ƒnderungsskript, Test mit SQL-Befehl)
							3. Server f¸r Anwendung provisionieren, einrichten und Anwendung deployen -> neue Instanzen greifen auf neue Anwendung zu.
							4. laufende User auf neue Version ¸bertragen und Server mit alter Version stoppen.
							5. Delta der alten DB von Backup-Time bis Stop der alten Version auf neue DB ¸bertragen
							-> geht bei der ƒnderung der kopierten DB etwas schief, kann deployment gestoppt werden
							-> Hat die alte Anwendung fehler, kann DB-Backup eingespielt werden. Delta an neuer DB muss aber in alte ¸bernommen werden
					- Entkopplung Anwendungs- und Datenbank‰nderung \cite[S. 333]{CD}
						- wird zwischen zwei Deployments ausgef¸hrt
						- wenn neue Version sich als stabil erwiesen hat
						- Versions-Bedingung der DB f¸r Applikations-Version -> app v248 ist kompatibel mit db v15 -> z.B. ¸ber Konfig-Info vor Deployment DB-Version abfragen (Grafik \cite[S. 333]{CD})									
			Strategien f¸r die Versionsverwaltung:
				- Branching und Merging 
					-> Branch erzeugt einen paralellen Entwicklungszweig \cite[S.154-159]{popp_konfig}
					-> SVN bietet hierf¸r den separaten Ast Branch an, w‰hrend der Hauptstamm im Trunk verbleibt
					-> Warum Branches? 
						- parallele Entwicklung am Branch f¸r Feature, w‰hrend auf dem trunk das release vorbereitet wird \cite[S. 157]{popp_konfig}
						- Integrations-Branches \cite[S. 389]{CD}
						- Wartungs-Branches
					-> Merging f¸hrt Branches zusammen \cite[S. 390-393]{CD}
						- aufw‰ndig wenn differenzen groﬂ und eine Menge Anpassungen notwendig sind den Branch in den Hauptstamm einzuf¸gen 
						- Kontinuierlich mergen: Branches nur f¸r kurze Zeit zuzulassen, 1-2 Tage, verringert die Nachteile des Branchings 
						- Empfehlung:
							- Branch nur f¸r Releases
							- ƒnderungen immer am Trunk
							- Mergen nur f¸r BugFixes am Release (Trunk -> R-Branch)
	Zusammenfassung:
		-> Anforderung aus dem ITIL-Release-Management schon fr¸h umsetzen -> wenn Problem erst kurz vor dem Release auftauchen kann es hektisch werden (DevOps)

4. Entwicklungsstand CD:
	- Entwicklung von Lˆsungsstrategien f¸r adesso setzt Betrachtung des derzeitigen Auslieferugsprozesses vorraus.
	- Es wird keien heterogene Projektlandschaft erwartet, unterschiedliche Projekte haben unterschiedliche Anforderungen
	- Erwartung, des es schon Bem¸hungen in Richtung CD gibt.

	4.1 Ausgangssituation f¸r die Untersuchung: (Grund der Untersuchung, Ansatzpunkte f¸r CD zu finden)
		- Technologische Unterscheidung der Projekte nach Java, MS, Mainframe, CMS, Fokus aber auf Java / JEE
		- CI-System bei adesso f¸r Kompilierung und Integrationstest sorgt f¸r Klarheit ¸ber Stand des Projekes
		- Bereitstellung eines spezialisierten support Teams -> Aufgaben Einrichtung der Prozesse und Beratung
		- Grund f¸r Untersuchung IST-Zustand ist die Integratiosf‰higkeit der Werkzeuge sowie Prozesse
		- Untersucht wird mit dem Reifegradmodell f¸r CI von UrbanCode -> Warum ist es geeignet?
		- Gewinnausnutzung von kurzen Iterationen und entwickelten Programmfunktionalit‰ten benˆtigt Anpassung des Auslieferungsprozesses
	
	4.2 Erhebungsmethode: (Welche Methoden sind mˆglich, welche Form wird gew‰hlt)
		- Ausliefreungsprozess unterliegt unterschiedlichen Rahmenbedingungen
		- CI-Team bietet spezialisierte Kenntnisse rund um das Thema Auslieferung und Integration an.
		- CI-Team ist geeignet den Auslieferungsprozess darzustellen
		- Meinungen und Standpunkte sowie Prozessbeschreibungen sollen befragt werden
		- Mˆglichkeiten der Befragung: Interview, Fragebogen
		- Kleiner Nutzerkreis spricht f¸r Interview aber zeitaufwand und asynchrones Antwortverhalten beg¸nstigt Fragebogen
		- Der Fragebogen wird pr‰feriert wegen asynchronit‰t
		- Zusammensetzung Fragebogen: wenigen Textfeldern, mehr Zustimmungsfragen, Felder f¸r Anmerkungen
		- Zustimmungsfragen kommen aus Refegradmodell von UrbanCode und Anti-Pattern von Humble / Farley
		- Reifegradmodell ist f¸r Selbstevaluierung bestimmt, derzeit keine weiteres bekannt
		- Unterteilung des Fragebogens in Sektionen Commit-Stage, Acceptance-Stage, Deplyoment
		- Commit-Stage f¸r Build-Prozess, Acceptance-Stage f¸r Integratios- und Abnhametests, Deployment kritische Komponente der Auslieferung
	
	4.3 Auswertung und Darstellung der Ergebnisse: (Was hat die Untersuchung gebracht)
		- Antwort von drei Mitarbeitern des CI-Team, repr‰sentativ, da dies wesentlicher Kern
		- keine vollst‰ndige Deckung der Antworten, deshalb Vermutung keine durchweg standardisiertes Verfahren
	
		4.3.1 Phasen des derzeitigen Auslieferungsprozessen
		- Phasen: Projekt-Setup, Entwicklung, Integrationstest, Auslieferung
		- Abh‰nig vom Auftraggeber
		- Entwicklung umfasst die Subphasen Build, Unittest, autom. Deployment auf Test, Bevorzugung von TDD
		- Kein Zugriff auf die Produktivumgebung, nur Ausliefreung von WAR / EAR
		
		4.3.2 Commit-Stage:
		- Jenkins CI-Server mit Maven / Ant als Build-Tool
		- Zentraler Prozess -> Anti-Pattern: Build-Prozess auf Entwickler-PC nicht replizierbar und instabil
		- Softwarepakete werden mit Versionsummer versehen im zentralen Repository abgelegt und keine zweites Mal gebaut
		- Anti-Pattern: Build-Prozess der selben Version wird wiederholt
		- 3rd Party Libs mit Maven in zentralen Repository (Nexus)
		- Automatische Prozessauslˆsung f¸r Build und Test
		- Nutzung CI-System Abh‰ngig vom Projekt von Team, aber streng empfohlen !!!
		
		4.3.3 Acceptance-Stage:
		- Software muss Qualit‰tskriterien / Abnahmekriterien entsprechen
		- keine forcierung von 100% Testabdeckung -> w‰re auch tr¸gerisch!!!
		- statische Analyse mit Sonar
		- Weitere Werkzeuge wie FindBugs, PMD, JoCoCo, Cobertura
		- Testverfahren auf das Gesamtsystem gegen funktionale und nicht-funktionale Anforderungen
		- Automatisierte Akzeptanztests geben schnelle R¸ckmeldung welche Anforderungne erf¸llt werden
		- Prozess: 1. SVN-Check-In 2. Kompilieren 3. alle Tests -> Dadurch Regressiostest!
		- Testberichte zeigen nur auf welche Tests (nicht) erfolgreich verliefen
		- !!! Welche Inhalte sollte ein guter Testbericht haben?
		
		4.3.4 Deployment:
		- Deploymet liefert Software in Ausf¸hrungsumgebung (Test / Produktion)
		- Commit und Acceptance kann zu Deployment f¸hren, aber Vorbereitung notwendig z.B. f¸r Jenkins, Tomcat, JBoss, Ant und Maven
		- Ausliefern in Cloud oder VM hochfahren mit Chef, schon bei adesso als Projekt verwendet
	
	4.4 Ankn¸pfungspukte f¸r CD: 
	- Wenn mˆglich sollte kompilieren und testen automatisch auf CI-Systemen ausf¸hren
	- Hoher Aufwand wenn zu sp‰t integriert wird und Fehler entdeckt werden -> komplex Systeme
	- Wenn nur WAR- und EAR-Files geliefert werden ist kein Zugriff auf Produktivsystem mˆglich
	- Rechtliche Implikationen schr‰nken dieses Verfahren auch ein
	- Agiles Vorgehen z.B. Scrum oder advantage produzieren zu erst die wichtigen Funktionalit‰ten -> sollte auch vom Kunden direkt getest werden kˆnnen
	- Empfehlung f¸r vorkonfigurierte Tool-Chain mit Deployment-Tool f¸r Self-Service-Portal um CD und Deployment-Pipeline anzubieten
	- Geeignete Tools sollen im n‰chsten Kaptiel untersucht werden

5. Evaluierung der Werkzeuge:
	- Evaluierung von Go, Deployinator, Dreadnot -> sind durch adesso vorgegeben
	- Werkzeuge stehen im Zusammenhang mit CD: Ziel Komplexit‰t von CD veringern
	- Komplexit‰ten durch:
		- unsicherer Prozess wenn automatierung nur aus Script-Sammlung besteht
		- Ausrollen von Webanwendungen in Produktion -> Installation Server und Infrastruktur
	- kein unverseller Problemlˆser erwartet, mˆglicher Weise sind Tools in verschiedenen Kategorien beheimatet
	- CD umfasst die Konzepte von CI, CI System schon vorhanden (Jenkins)
	- Deployment-Pipeline in Web-Server bei adesso durch Jenkins-Plug-In schon mˆglich
	- Zu untersuchende Werkzeuge stehen in Konkurrenz zum bestehenden System
	
	5.1 Kriterien f¸r die Evaluierung:
		- Soll kl‰ren ob die Werkzeuge die Deployment-Pipeline bei adesso verbessern kˆnnten
		- Genauer Funktiosumfang der Werkzeuge vorab noch nicht bekannt -> eingehende Grobbetrachtung notwendig
		- Einordnung in Werkzeugklassen: Go -> CI-System, Deployinator und Dreadnot -> Self-Service-Portal f¸r Deplyoment
		- Grundlegene Eigenschaften f¸r Einrichtung, Betrieb und Integration in Umgebung sind vergleichbar
		- Funktionsumfang f¸r CD setzen an unterschiedlichen Ende, mˆglicherweise ein gegenseitige Erg‰nzung von CI <-> SSP 
		- Deshalb Untersuchung welche CD-Funktionen abgebildet werden nach Management, Commit-, Acceptance-, Deployment
	
		5.1.1 Kriterien f¸r Einrichtung, Betrieb und Integration
		- Installationsanweisungen
		- Installatiosverhalten und 
		- Systemvoraussetzungen
		- Mˆglichkeiten das System zu integrieren
		- Lizenzen / Kosten
		
		5.1.2 Anforderungen f¸r eine Deployment-Pipeline aus CD
		- nach CD, unterscheidung der Anforderungen nach Stages
		
		5.1.2.1 Management von CD
		- Prozess abbilden
		- Quality Gates
		- Prozess-Trigger
		- Reporting Build, Test, Metriken
		
		5.1.2.2 Commit-Stage
		- Unterst¸tzt Versionsverwaltungssysteme (SVN,CVS,Git)
		- Build-Tools anstoﬂen (Ant,Maven,?)
		- Repository f¸r Artefakte
		- Unit-Tests (JUnit)
		- Code-Analyse (Sonar, FindBugs, etc.)
		
		5.1.2.3 Acceptance-Stage
		- Konfiguration Testumgebung
		- Bin‰rdaten deployen
		- Smoke-Test
		- Akzeptanztests
		
		5.1.2.4 Deployment
		- Self-Service-Deployment
	
	5.2 Ergebnisse:
	
		5.2.1 Go
		- Setup:
		
		- Implementierung einer Pipeline:
			- HF empfehlen wenn noch kein Projekt vorhanden: funktionierendes Skelett mit "Hello World" \cite[S. 132]{CD}
			- Implementierung eines Testprojektes um Go zu testen
				
		5.2.2 Deployinator
		- Setup:
		
		- Implementierung einer Pipeline
			- Nutzung des Testprojektes von Go
		
		5.2.3 Dreadnot
		
	5.3 Vergleich zum derzeitigen Auslieferungssystem
	
	5.3 Zusammenfassung:
	- Zwei unterschiedliche Kategorien von Werkzeugen -> CI-System vs. Self-Service-Portal f¸r Deployment
	- Keines ohne Anpassung geeignet
	- Dreadnot bieten gute Deployment Unterst¸tzung, Mˆlichkeit als SSP in Lieferprozess zu integrieren

6. Lˆsungskonzept f¸r CD bei adesso:

	6.1 Szenario
		- Einsatz von embedded Server verringert Komplexit‰t -> Jetty, aber nur JSP Seiten, f¸r Tauschplattform aber geeignet
		- Abnahme auf Testsystem
		- Einrichten eines Selfservice Portal um Version von Test auf Produktion zu bringen -> Teilabnahme damit erfolgt
		- Muss als Aufgabe im Projekt betitelt werden
	
	6.2 Prozessegestalltung
		- Tools: SVN -> Jenkis CI -> Dreadnot / Deployinator
		- Infrastruktur: SVN (externes System) -> CI-Server + Dreadnot + Puppet / Chef -> Deployment zu Node-System
	
	6.3 Konzep einer Deployment Pipeline
	
	6.4 Werkzeugkonfiguration

7: Fazit:
	- "CD zu implementieren erfordert mehr als nur Werkzeuge zu kaufen und automatisierung zu implementieren, es h‰ngt viel mehr von einer effektiven Zusammenarbeit ab aller im Auslierfungsprozess beteiligter. \cite[S. 417]{CD}