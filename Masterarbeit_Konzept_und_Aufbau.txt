1. Einleitung: (Einleitung in das Thema, Begründung sich damit zu bschäftigen, Zielstellung)
	- Beispiel Kent Beck liefert in de 90er Jahren jeden Tag in die Produktivumgebung
	- Agiles Manifest nennt 12 Prinzipien, erstes beinhaltes kontinuierliches Ausliefern
	- Scrum	liefert nach jeder Iteration für den Kunden nützliche Funktionen
	- Bedeutet aber jedes Mal eine Inbetriebnahme
	- Nach §640BGB Werkabnahme erfolderlich
	- CD soll aber Komplexität reduzieren
!	- CD setzt nicht auf spezielle Basistechnologien auf sondern ist ein Konzept um Prozesse beim Softwarerelease zu automatisieren 
!	- CD im engen Zusammenhang mit DevOps-Bewegung -> Entwicklung und IT-Betrieb müssen enger zusammenarbeiten
!	- CD und DevOps fokusieren nicht speziell Web-Anwendungen, Ideen kommen aber aus dem Web 2.0 / Cloud Umfeld
	- Umsetzung von CD mit Scripten möglich, aber keine klarer und wiederholbarer Prozess
	- Problematik hatten auch verschiedene Webprojekte -> Einzellösungen und proprietäre Lösungen
	- Vorstellung von adesso als Dienstleister und Softwareentwicklung unter Java / JEE
	- Eigenes Vorgehensmodell advantage stellt fühstmöglich Installation in den Vordergrund
	- Interesse an CD, mit Kernfokus Java / JEE und Web-Anwendungen und Vorschlag von Go, Deployinator und Dreadnot
	- Ziel: Tools untersuchen, Möglichkeit such Auslieferungsprozess zu ergänzen, Kernfrage CD beleuchten
	- Eingrenzung der Betrachtungsweise zu gunsten von Web-Anwendungen im Java-Technologie-Stack
	- Vor untersuchung der Werkzeugen Betrachtung von CD
		- Ideen von CD ist weiterentwicklung von CI
		- basiert auf Buch von HF und DevOps-Artikel von 

2. Entstehung von CD:
	- Verstehen von CD notwendig um Tools bewerten zu können -> Auf Problemstellung von CD wird eingegangen
	- CD in enger Verbindung mit DevOps, was ist die DevOps-Bewegung und was sind ihre Motive. Wie ist CD durch diese beeinflusst
	- Aus DevOps leiten sich Konzepte für CD ab -> Ziele fürs Team, Definition of Done und RC, Prozessautomatisierung, Feedback
	- Ein Blick auf ITIL -> CD berührt die Domaine von ITIL Service-Transition im Bereich von Service- und Release-Management

	2.1 Problemstellung von CD:
		Problem 1: Wertzuwachs einer Iteration oft nicht direkt nutzbar -> Lange Releasezyklen
			- Iteratives Vorgehen in agilen VM priorisiert Funktionalitäten und produziert die Funktionalität mit dem höchsten Kundennutzen zu erst (Erster Durchstich / Grundsystem -> dann Funktionalitäten / Rapid Prototyping)
			- Web-2.0-Geschäft z.B. davon Abhängig, dass neue Funktionalitäten schnell dem User-Kreis zur Verfügung gestellt werden können -> Konkurrenz zuvor kommen (WebShop / soziales Netzwerk ... ) 
			- Schnelle Ausnutzung von neuen Programmfunktionalitäten in Produktion -> kann wirtschaftlichen Vorteil bringen -> Markt im Web-2.0 mit viel Bewegung
				-> Bsp: Flickr / Etsy -> neue Funktionalitäten unverzüglich am Markt verfügbar
			- Ziel nach Humble/Farley ist: nützliche und funktionierende Software so schnell wie möglich den Nutzern verfügbar machen.\cite[S. 11]{CD}
		Problem 2: BugFix nicht schnell einzuspielen
			- Gegensatz einmaliger Einführungsprozess für SW -> Abnahme... \cite[S. 169 ff]{steinweg04}
				-> Bsp: Banking-Software mit Einzeiler-Bug der erst Wochen nach Inbetriebnahme auffällt -> hoher Personalaufwand für Release, nächstes erst in Wochen geplant -> vermeidbare Kosten mit automatisierter Lösung
				-> BugFix muss schnell in Produktion gehen können -> Build-Pipeline
		Problem 3: Aufwand und Fehler von SW-Lieferung hoch
			- Einspielen einer Produktivversion mit viel Aufwand verbunden
				-> Beipsiel manuelles Deployment bei Versicherungsanwendung -> Night-Session -> Vorbereitung -> Personal
			- Manuelles vorgehen kann fehlerhaft verursachen -> Gründe \cite[S. 5-7 und 9-10]{CD}
			- fehlerhaft manuelles Deployment vermeiden -> CD basiert auf Prozesse und Automatisierung	
		Problem 4: Anwender-Feedback zu spät
			- Anwender erhalten erst zum Schluss die Möglichkeit der Einflussnahme  \cite[S. 179 ff]{steinweg04}
				-> Anitpattern: \cite[S. 7 ff]{CD}
			- Agiles Manifest schlägt ein direkte Kundeneinbindung in den Entwicklungsprozess mit ein \cite{manifesto}
				-> der Kunde muss frühzeitig eine Ausführbare Version in der Had halten können -> Verstäändigung von Kunde und Entwickle		
	
	2.2 Die DevOps-Bewegung:
		- Ausgehend von der belgischen Stadt Ghent, vertraute Gruppen nach agilen VM dort konentriert -> DevOps-Days (2009) \cite{cd_devops_1}
		- DevOps.com -> Slogan "Helping finish what Agile development started"
		- Chris Read: "At its heart it is the integration of Agile principles into Operations practices." -> "enabled the rise of the Cloud and Web 2.0 giants" \cite{cd_devops_stateofnation}
		- Agile VM wie XP haben Kommunikation zwischen Business und Entwicklung verbessert -> schnelles Feedback, engere Zusammenarbeit -> bessere SW entstand \cite{cd_devops_stateofnation}
		- jetzt: SW basierend auf dem feeback von Buisness -> neuer "Flaschenhals" entdeckt -> SW in Produktion \cite{cd_devops_stateofnation}
		- DevOps setzt Kommunikation in den Fokus und verschucht agilen Ansatz in Sys-Admin / IT-Betrieb zu bekommen -> Agile Techniken auch praktisch um Infrastrukturen zu managen\cite[S. 279]{CD}
		- Problem der Software-Welt: \cite{cd_devops_1}
			-> Angst bei Unternehmensführung vor Änderungen wenn die Anwendung erst einmal läuft, wegen fragiler Umgebung und bürokratischen Change-Management (ITIL) -> es vergeht viel Zeit bis ein neues Feature oder Bug-Fix eingeführt wird
			-> Risikobehaftete Auslieferung -> keine Sicherheit, ob die Software in der geplanten Umgebung läuft -> Verhalten wie erwartet? Hält es die Last aus?
			-> Lauffähigkeit nur auf Entwicklermaschinen bewiesen: Keine Test der Anwendung in produktiosgleicher Umgebung mit der erwarteten Last -> zu Viele Komponenten im Einsatz
			-> Bunkerdenken: Team-Splitt in Entwickler, tester, release Managers, System-Admins -> arbeiten in unterschiedlichen "Bunkern" und fire-and-forget Mentalität -> Hin-und-herschieben von Problemen zwischen den "Bunkern"
			-> Humble: Generelle Aufteilung von Dev und Ops als auch durch Governace-Framework wie Cobit und ITIL, die verhindern wollen, das Entwickler zu viel schaden anrichten. \cite{devops_enterprise}
		- DevOps ist aber kein technologie-Problem, Technologie ist aber der Schlüssel um DevOps-Problem zu lösen. DevOps ist ein Business Problem \cite{edwards10}
			-> - B will Gewinn erwirtschaften und benötigt Buisiness Process (Dev, QA, Sequrity und Betrieb) -> jeder Beteiligt den Prozess auszufüllen
			-> Enabling the Business
			-> DevOps works on improving the interaction and flow across IT functions
			-> Q: "How to enable a business to react to market forces as quickly as possible"
		- Ansatz von DevOps: \cite{cd_devops_1}
			-> developers, testers, managers, DBAs, network technicians, and sysadmins müssen selbses Ziel verfolgen: gute Software liefern -> "sysadmin coders" (Stephen Nelson-Smith)
			-> Entwicklung von Kommunikationsfähigkeiten, verständnis für das Gebiet auf dem SW geschrieben wird, verständnis für das darunter liegende Geschäft
			-> SW ist fehleranfällig, riskant und unvorhersehbar -> verweiss auf agiles manifest -> Weiterentwicklung mit technologischen Vorteilen durch Testen
			-> Lücke zwischen 'Dev complete' und "live, in production, stable, making money" \cite{cd_devops_stateofnation}
			-> Typischerweise sind die Sys-Admins für das ausbringen der SW verantwortlich -> haben Vorbehalte da sie die sw nicht kennen, ihr nicht vertrauen, die entwickler nicht kennen -> Erwartungshaltung gute SW zu liefern gering
			-> DevOps karaktresiert durch Leute die in verschiedenen Disziplinen zuhause sind -> Infrastruktur, Configuration, test schreiben, debugen, ausliefern -> Kommunikation herstellen können
			-> Bewegung von Sys-Admin ausgegangen
		- Chris Read: Im Gegensatz zu CI, das klar definiert ist, ist dev-ops vage definiert und auf einfach nur ein Platzhalter um betriebsrelewandte Produkte und Dienste in Stellung zu bringen \cite{cd_devops_stateofnation}
		- Wie wird DevOps möglich: \cite{cd_devops_stateofnation}
			-> Auflösen von tief verwurzelten Funktionsstrukturen, hin zu funktionsübergreifenden Teams mit Entwicklern, testern, Business Analysten und Investition in Prozessautomatisierung
			-> Kontinuierliche kleine Änderungen am System steigern die Stabilität und senken das operative Risiko
			-> Agile Principien in den IT-Betrieb
			-> Alte Welt: Architekt schreibt Dokumentation -> Developer Entwickelt System, Tester git SW mit Fehlern zurück, Betrieb versucht die SW zum laufen zu bringen.
			-> Verbindung zwischen Dev und Ops herstellen
			-> Lösungskonzept Cloud Service, vermeidet aufwändige und manuelle Prozesse um Server zu Provisionieren. Warten auf Server kann negative Auswirkungen auf den dne Projektfortschritt haben
			-> Eine Person im Team mit Fähigkeiten für Abnahme oder Netzwerk, aber auch Spezialisten die Richtlinien entwerfen und Rat geben.
			-> gemeinsamme Verantwortlichketien für die Lieferkette -> Dev und Ops als geschlossene Einhei
			-> automatisierung und Tool-Chain als Erfolgsschlüssel für DevOps
			-> Verweis auf Amazon Web Service als erfolgreiche Umsetzung von DevOps bei der die eigenen Entwickler schnell benötigte Server provisionieren können.
		- Einführung von DevOps-Kultur und Praktiken ist eine notwendige Bedingung um CD zu erreichen.\cite{devops_enterprise}
		- CD löst die Probleme von DevOps ist deshalb als ein fester Bestandteil von DevOps zu sehen. CD wird ohne die Berücksichtigung von DevOps nicht vollständig möglich sein. (Implikation für adesso in Lieferstrategie!)
		- Chad Dickerson CEO bie Etsy: Designer und Produktmanager sind im Team und Entwicklen mit, Dev und Ops arbeiten eng zusammen -> Etsy erreichte dadurch in einem Monat 517 Deployments in Produktion angestoßen von 63 unterschiedlichen MA.
		
	2.2 Konzepte von CD
		- Feedback Prozess (Auslösen, Erhalten, Reaktion) \cite[S. 13 ff]{CD}
			- SW Decomposition führt zu vier Komponenten -> ausführbarer Code, Konfiguration, Ausführungsumgebung, Date
			- Verhalten der Anwendung wird von allen vier Komponenten beeinflusst -> alle müssen unter Kontrolle bleiben
			- Jede Änderung am Code sollte zu Kompilierung und testen der Binarys führen.
			- Kompilierter Code sollte in jeder Umgebung der gleiche sein -> Test / Produktion
			- Alles was zwischne Umgebungen wechselt sollte als Konfiguration gehalten werden -> Änderung an der Konfiguration testen
			- Änderung an den Daten -> Testen -> Feedback
			- Kompilierprozess zeigt das Syntax valide ist
			- Unit-Test zeigen das der Code sich wie erwartet verhält
			- Test-Abdeckung und Metriken ....
			- Acceptance Test -> konform mit den geschäftlichen Akeptanzkriterien / Kundenanforderungen
			- Nichtfunktioale Test zeigen Kapazität, Verfügbarkeit, Sicherheit, ...
			- manuelles Testen -> exploratives Testen und Demonstration dem Kunden gegenüber
			- Automatisierung führt zu schnellem Feedback -> manuelle Prozesse hängen von der verfügbarkeit der Mitarbeiter ab -> wann wird die Aufgabe erledigt?
			- Manuelles kompilieren, testen und deployment verschwendet Zeit kreativer Mitarbeiter -> langweilige und wenig herausragende Tätigkeit -> trägt nicht zur Problemlösung bei und kostet teure Ressourcen.
			- Testen ist Maschinenarbeit -> arbeiten schnell
		- Erhofter Nutzen (Team, Fehler, Streß, Flexibilität) \cite[S. 17 ff]{CD}
			- Self-Service für Entwickler, Tester, Betrieb, Support -> Version der Software für die Umgebung bestimmen
			- Erfahrung von H/F MA wartet auf ein gutes Build -> Endlose Emails werden gesendet -> Tickets geöffnet -> ineffiziente Kommunikation -> bei verteielten Team sehr ineffizient
			- Vorteile jederzeit jede Version in die Umgebung bereitstellen zu können:
				- Verifizieren von Verhalten gegenüber äleren Versionen durch Tester ("war das schon immer so?")
				- Support kann released Version in Umgebung deployen um Fehler zu reproduzieren
				- Betrieb kann letzte "gute" Version im Katastrophenfall wieder einspielen (kein manuelles Backup der alten Version wie bei z.B. bei Kaladent
				- Push-a-Button-Release
			- Fehlerreduzierung durch automatisches Konfigurationsmanagement: 
				- manuelles Konfigurationsmanagement ist abhängig von Fähigkeit und Sorgfältigkeit des Einzelnen in periodisch wiederholenden Aufgaben.
				- Probleme durch unterschiedliche Konfiguration der Systeme Test / Prod: nicht reproduzierbare Fehler
				- Typo schwer zu entdecken, Versionsmanagement bietet die Möglichkeit Änderungen zu tracken
				- Stand der 3rd-Party Bibliothken, Laufzeitumgebung, Server-Version, Properties für Konfiguration mit unterschiedlichen Werten
				- Konfiguratiosdatein, Datenbank-Skripte und Schemas, Build-Skripte, Tests, Entwicklungsumgebungen, Konfiguration von OS
			- Stressvermeidung
				- "just get something working" vor einem geplanten Release, hoher Druck 
					-> Alternative: Release nur mit einem Button in wenigen Minuten getan
					-> Zurücksetzen mit automatierung genauso einfach
					-> Häuffiges Release so einfacher, Delta zwischen aktueller und neuer Version klein
			- Deployment Flexibilität
				- Ziel: Neue Umgebung mit eine paar Konfiguratiosanpassungen einrichten
				- Flexibilität kommt durch die Platzierung der Software, wo immer diese benötit wird -> flexible Provisionierung
		- Release-Kandidat (RC) \cite[S. 22]{CD}
			- Änderung im Code führt möglicher Weise zu einer releasfähigen Software
			- Jede Änderung muss validiert werde -> Build, Deployment, Test-Prozess entscheiden
			- RC = es sind keine Fehler gefunden worden & die Akzeptanzkriterien des Kunden werden erfüllt
			- Traditionelles Release: Werkabnahme, Pilotbetrieb, Abnhame, Roll-out / Training, going live \cite[S. 172 f]{steinweg04}
			- nach HF kein Bedarf für manuelles Testen wenn umfassende automatisierte Test und autom. Deployment
			- nach HF führt das Testen im Anschluss an den Entwicklungsprozess zu einer deutlichen absenkung der Qualität -> für Bug-Fixing keine Zeit mehr wenn Release vor der Tür steht
			- HF führen an: Entwickler vergessen was sie gemacht haben als sie den Fehler eingebaut haben -> Funktioalität hat sich in der Zwischenzeit geändert -> Späte Fehlersuche aufwändig
			- jede Änderung fügt einen Wert hinzu -> verbessert das System an dem gearbeitet wird 
			- Im Gegensatz kann aber jede Änderung Fehler in ein schon laufendes System bringen -> überprüfung setzt ausführen der Software vorraus -> Integration notwendig
			- integration unvorhersehbarer schwer zu managender Prozess -> deshalb gerne nach hinten verschoben
			- Jede Änderung sollte den Prozess von bauen und testen anstoßen -> CI-System
		- wiederholbarer, verlässlicher Prozess -> automatisierung  (Prinzip der Softwarelieferung)\cite[S. 24]{CD}
			- Prinzipien nach HF: 
				- wiederholbarer & verlässlicher Prozess
					- Einfachheit Software zu liefern -> wenn gut getestet
					- Ein-Knopf-Lösung
					- setzt auotmatisierung und versionskontrolle von build, deploy, test und release vorraus
					- Deploying setzt vorraus: provisionierung und managen von umgebung in der sw läuft, istallation der richtigen version, konfiguration mit richtig daten oder zustand
				- vollständige automatisierung
					- automatisierter deployment / sw release Prozess
					- akzeptanz test
					- Datenbank installation und konfiguration
					- nicht automatisiert werden können: exploratives testen, demonstrationen, compliance -> menschliche interaktion
					- am anfang einfache es manuell zu tun -> beim 10. Mal aber nicht mehr -> Aufwand und Fehler!
				- alles in Versionskontrolle
					- alles für build, deploy, test, release -> in versions kontrolle
					- Anforderungsdokumente, test-skripte, autom. test-fälle, netzwerk-config-skripte, deployment-skript, datenbank-creation, upgrade, downgrade, initialisierungs-skripte, libs, toolchain, technische-doku
				- Qualität
					- fürhes erkennen von Fehlern senkt die Kosten die zu beseitigen
					- ci, automatisiertes testen, autom. deployment -> helfen fehler früh wie möglich im Prozess zu erkennen
					- erfodert Disziplin, Fehler dann unverzüglich zu beseitigen -> Testen ist keine Phase am Ende des Entwicklungsprozesses
					- Teste ist keien Domaine der Tester -> Jeder ist für die Qualität verantwortlich -> (Woher: Manifesto / XP?)
				- Def of Done
					- HF denken, feature erst Fertig, wenn es dem Nutzer einen Wert bringt -> nicht immer praktikabel, da es längere Zeit dauern kann bis externe Nutzer einen Nutze haben
					- Deshalb: DOD -> erforlgreich vorgeführt, demonstriert und ausprobiert durch eine Repräsentanten der Nutzergruppe in eine Produktions-ähnlichen Umgebung
					- nicht 80%-fertig eher -> noch 3 PT Arbeit oder ähnliches
					- keine Einzelner sondern eine Team von testern, it-betrieb, support, entwickler müssen für "done" zusammenarbeiten
				- Verantwortlichkeit
					- Gemeinsamme Verantwortung für den Lieferprozess -> Sollte Ziel der Organisation sein
					- In kleinen Teams / Organisationen besteht häufig vollständige Kontrolle über die benötigten Ressourcen
					- Große Orgaisationen möglicherweise isolierende Barrieren zwischen Rollen und Leuten -> Entwicklerr - Tester - Ping Pong
					- Möglichkeit schaffen für eine einfachen Kommunikation zwischen Leuten
					- System für Status der Software -> Zustand, kompilierte Pakete, welche Tests, zustand der Umgebungen
					- System sollte die Möglichkeit bereitstellen den einzelnen die Arbeit zu erleichtern -> Self-Service Deplyoment für Tester etc.
					-> DevOps-Bewegung: Zusammenarbeit zwischen den Beteiligten im SW-Lieferprozess fördern
				- Continuous Improvement
					
	2.4 Exkurs - ITIL, DevOps und CD:
		- ITIL ist ein Prozessstandard für IT-Service-Management, welches vom Office of Government Commerce herausgegeben wird \cite{itil_boetcher}
		- Bedeutung für CD hat das Change- und Release Management aus dem ITIL-Buch Service Transition, welches Prozesse und Verfahren beschreibt -> neue / geänderte IT-Services in den operativen Betrieb zu heben.
		- ITIL Service Transitions wird von Service-Design angestoßen und mündet in Service Operation \cite[S. 81 ff]{itil_boetcher}
		- Service Transition Kernprozesse: Transition Planning und Support, Change Management, Service Asset & Configuration Management, Release & Deployment Management
		- ITIL Change- und Release Management hat synergienm mit DevOps -> Implikationen für CD \cite{DevOpsITIL}
		- Ziel ist Schutz und Erhalt der Systemintegrität der bestehden Infrastruktur \cite[S. 108 ff]{itil_boetcher}
		- unvorhergesehene Beeinträchtigungen bei der Einführung neuer / geänderter Dienste zu vermeiden
		- ITIL hat Rückhalt in größeren Organisationen mit etablierten Teams für den IT-Betrieb und mit einer risikoscheuen Haltung. DevOps eher bei StartUps zu finden.  \cite{DevOpsITIL}
		- Change Management: Ablaufsteuerung von Veräderungsmaßnahmen \cite[S. 89 ff]{itil_boetcher}
		- Aktivitäten: erstellen und Dok von RFC, Zulassen und Beurteilen von RFC, Autorisieren, Koordinieren der Implementierung, Prüfen des Ergebnisses.
		- Release-Management
		- Aktivitäten: Release-Richtlinien, Planen von Release, Erstellen und Testen von Release, Implementieren von R, Support bei Einführung, Abschließen von Release-Projekt
		- Als Methoden wird die Trennung von Entwicklungs-, Test,- und Produktivumgebung empfohlen sowie die nutzung von SW-Verteilungstools
		- Unterschieden werden im Release-Management: Major R., Minor R. und Emergency Fix
		- ITIL Release-Richtlinien in Richtung CD -> automatische SW-Verteilung, Sequentielles Roll-Out, Push
		- Verifizierung von Releases in einer 1zu1 Abildung der Produktivumgebung durch Testverfahren \cite[S. 114]{itil_boetcher}
		- ITIL Release-Management verlangt Fehleridentifikation, Ursachenanalyse, Fehlerbeseitigung + funktionale und operationales Testen nach entworfenen Testkonzepten
			-> Installierbarkeit, Integration in bestehende Infrastruktur, auswirkung auf Systemstabilität und Leistungsverhalten
			-> Funktionalitätstests ob erwartetes Verhalten auch tatsächlich auftritt
			-> Know-How Transfer von Dev auf Release-Manager
		- Validierung von SW in operativer Umgebung mit kleinem Anwenderkrei -> strukturierter Feedback-Prozess
		- Release Aktivitäten, die CD berühren (typisch): Logistik, Paketierung und Distribution auf Depot-Server, Verteilung auf Zielrechner, Konfiguratiosmanagement
		- chronologische Dokumentation aller Änderungen mit Versionskontrolle (SVN)
		- nach Humble: ITIL Prinzipien und Praktiken in einer leichtgewichtigen Art verfolgen und die Ziele eines effektiven Service Management erreichen durch schnelles und verlässlichen Lieferprozess \cite{itil_cd}
		- CD reduziert Risiko der Änderung durch reguläres ausführen von Realeases
		-> Anforderung ist aber das Ops und Dev eng und früh im Projekt zusammen arbeiten, automatisierte Prozesse, Provisionierung von Produktions- und Testumgebung
		-> Deployment-Pipeline unterstützt Change-Management effektiv, da Lieferprozess kontrolliert wird -> Revisions und compliance tool wenn folgendes auf das verwendete Tool zutrifft:
			-> Welche Version ist aktuell in welcher Umgebung deployt?
			-> Durch welche Teile der Pipeline ist welche Version durch, mit welchem Ergebnis?
			-> Wer hat das Build, Test und Deploymetn ausgelöst?
			-> Zurückverfolgung von Deployment zurück zur Vreison im SVN
			-> Prozess-Metriken wie Durchlaufzeit
		-> CD ist effektiver Weg für leichtgewichtiges Mechanismen des ITIL Change-Prozesses durch etabliertes und häufig genutzten Change Prozess.
		- Kontinuierliches Monitoring und Feedback
		- nach Minick Release Manager natürliche DevOps-Vermittler
			
	2.5 Rechtlich und vertragliche Implekationen von CD:
	
	2.6 Zusammenfassung
		- DevOps und CD fokusieren stark Web-Technologien
		- DevOps zielt auf die Kommunikationsprolblematik zwischen Entwicklung und IT-Betrieb 
			-> DevOps schlägt stärkere Einbindung von IT-Betrieb in Dev vor 
			-> Know-How-Mix in den Teams notwendig 
			-> Dev soll selbst Infrastruktur provisionieren können 
			-> Produktions und Testumgebung identisch (Setup / System)
		- CD stellt klaren Prozess mit Vorgaben zu Automatisierung / Konfigurationsmanagement / Qualität / Def of Done / Verantwortlichkeiten bereit.
		- CD unterstützt ITIL Change und Release Management, wenn ITIL in leichtgewichtiger Art und Weise betrieben wird.

Deployment Pipeline und Liefersystem
	
	Einleitung:
		- Bezug zu DevOps: DevOps kann die Deployment-Pipeline als Realisierung eines Liefersystems betrachtet werden
			-> Deployment-Pipeline bildet den Prozess auf ein Liefersystems ab
		- Bezug zu untersuchenden Werkzeugen: Soll den Kontext der Werkzeuge zeigen und Vergleich zum derzeitigen Lieferprozess ermöglichen
			-> speziell Werkzeuge: welche Konzepte von CD und der DP werden verwirklicht -> Welche Anforderungen aus CD können damit umgesetzt werden.
			-> speziell adesso-Lieferprozess: Welche Konzepte werden derzeit umgesetzt, was wird für das Liefersystem vorgeschlagen
		- Deployment-Pipeline untersucht den Aufbau -> Build und Deployment-Skripting für Automatisierung
			- automatisches Deployment in die Produktivumgebung erfordert Erfüllung aller aktzeptanz Kriterien, funktional als auch nicht funktional
			- manuelle Test sind aufwändig und Kostenintensiv, Exploratives Testen ist aber nur manuell möglich
		- Liefersystem befasst sich mit Infrastruktur und Umgebung die CD ermöglicht / Untersuchung von Problemstellung aus Datenbanken, wenn automatisiert ausgeleifert wird / Umgang mit neuen noch nicht vollständigen Funktionalitäten / Konflikte durch Versionsmanagement vermeiden
			- Um Test in Produktivumgebung ähnlicher Umgebung durchzuführen ist schnelle proivisionierung von Infrastruktur notwendig und Verteilung der RC, in der (Web-)Produktivumgebung muss die Aktualisierung der 
				-> Liefersystem muss durchdacht und geplant sein
				
	Deployment Pipeline nach HF:
		DP-Einleitung:
			- Deployment-Pipeline ist Grundkonzept des Liefersystems, welches auf CI aufbaut.
				- Exkurs CI:
					Features von CI nach Duvall:
						- Frühere Problemidentifizierung durch CI \cite[S. 6]{Duvall07}
							- arbeiten alle Softwarekomponenten zusammen
							- Wie komplex ist der Quellcode
							- Werdem im Tema Coding standards umgesetzt
							- Wie hoch ist die Testabdeckung
							- Alle Tests auch nach letzten Änderung erfolgreich
							- Werden die Kapazitätsanforderungen erfüllt
							- Funktionierte das letzte Deployment
						- "Build Software at Every Change" \cite[S. 4]{Duvall07}
							- 
						- CI-Szenario \cite[S. 5]{Duvall07}
							-> Abbildung in \cite[S. 5]{Duvall07}
				- frühe und kontinuierliche Integration der Software gibt schnelles und frühes Feedback, ob alle Komponenten in späterer Produktionsumgebung zusammenspielen 
				- Abrenzung zu CI: -> CD = CI + automatisierte Akeptanztests + Deployment in Produktion  \cite[S. 105]{CD}
				-> Grafik von Schlegel: Javamagazin: CD-CI
			- CI nicht genug:
				- HF sehen, CI ist nicht genug da nur auf Dev-Teams fokussiert -> Output von CI ist Input für manuelles Testen und den Rest des Release-Systems  \cite[S. 105]{CD}				
		Ziele der DP:
			Problembeschreibung:
				- Verschwendung in Release-System durch: \cite[S. 105]{CD}
					- Dokumente oder Fixes auf die Build / Ops warten
					- Tester warten auf gute "Builds" 
					- Dev erhält Bug-Reports wochen nach dem schon zu neuen Funktionalitäten übergegangen wird
					- Entdeckung am Ende des Dev-Prozesses, das die Architektur nicht die nicht-funktionalen Anforderungen erfüllt
				-> erhöht die Gefahr von fehlerhafter Software durch lange Feedback-Zyklen zwischen Dev - Test und Ops
				- Problem des Release: bei Scheitern, Business muss auf neue Funktionalitäten warten oder kritische Betriebsressourcen sind gestört. Lösung:
					- Release Plan bei dem jeder zugriff hat
					- maximale Automatisierung / minimale fehlerbehaftete manuelle Eingriffe
					- routiniertes Training in Produktions-ähnlicher Umgebung
					- Möglichkeit des Zurückgehensm wenn etwas schief geht
					- Strategie, Konfiguration und Produktions-Daten als Teil des Updates / Rollback \cite[S. 129]{CD}
			Lösungsansatz nach HF:
				Technisch.- organisatorische Lösung:
					- HF schlagen eine automatisierte DP vor -> da automatische Manifestierung des Lieferprozesses
					- Entwicklung eines Modells, um Software vom Check-In zum Release zu bekommen -> "Concept to Cash" (Wertstromanalyse des Lieferprozesses)
					- Neu Form der Zusammenarbeit wird benötigt: 
					- Deployment Pipeline kann nur durch gute Zusammenarbeit zwischen den beteiligten Individuen entstehen
				Prozessvorschlag:
					- das Build durchläuft die Pipeline bis zum Release mehrfach -> in Stufen: 
						- Delivery Team
						- Version Control
						- Build & Test
						- Automated Acceptance Test
						- User Acceptance Test
						- Release
					- Grafik -> Sequenzdiagramm \cite[S. 109]{CD}
					- automatisierung der Teilschritte durch Skripte und Tool-Chain
						-> Fundamental: eine automatisierter Softwarelieferprozess schließt menschliche Handlung nicht aus, 
							-> stellt sicher das fehleranfällige und komplexe schritte automatisiert, wiederholbar und verlässlich sind!					
				Vorteile:
					- HF sehen in dieser Strategie folgende Vorteile:
						- effektiv wenn nur gründlich getestet SW in Produktion geliefert wird -> Test bei jedem Durchlauf der Deployment-Pipeline
							- wird nur durch Reihe von automatisierten Akzeptanztests möglich
						- Ein derartiger Process ist schnell, wiederholbar und verlässlich
						- auch dringende Bugfixes durchlaufen den gleichen Prozess und werden auf gleiche Weise getestet wie normales Release
						- Disziplin der Deployment Pipeline schwächt Fehler ab, die durch neue Konfiguration oder unvorhersehbare Interaktion der beteiligen Komponenten der Systemumgebung entstehen können
		Struktur der DP:
			- Grafik -> Basic deployment pipeline \cite[S. 111]{CD}
			- Pipeline kann in Stages untergliedert werden, Einheiten im Lieferprozess: Commit-Stage, Autom. Akzeptance Stage, Man- test-Stage, Release-Stage \cite[S. 109-110]{CD}
				-> Commit Stage: 
					-> Prozess von CI
					- stellt sicher, das das System auf dem technischen Niveau arbeitet -> es kompiliert, Komponententests sind erfolgreich und Code-Analyse ist erfolgreich
					- beginnt mit Commit von Änderungen die ein Entwickler am Quellcode vorgenommen hat -> Versionskontrollsystem
					- CI-System reagiert mit neuer Instanz des Softwarelieferprozesses -> Laufzeit sollte 5-10 Minuten (ideal) -> Paralellisierung \cite[S. 105-120]{CD}
					- Schritte: Kompilieren / Commit-Test (Komponententests) / Binärdaten erzeugen / statische Codeanalyse (White-Box) / Artefakte wie Testdantebank erstellen \cite[S. 120]{CD}
					- Metriken: Testabdeckung / Kodedubletten / Zyklomatische Komplexität / Afferente und efferente Kopplung / Anzahl von Warnungen / Code Style \cite[S. 121]{CD}
						-> Testabdeckung: Tools wie Sonar berechnen die Abdeckung von Code-zeilen, die von einem Test abgedeckt werden. \cite{sonar_testcoverage}
						-> Zyklomatische Zahl misst die strukturelle Komplexität des Quellcodes an hand des Kontrollflussgraphen und gibt die menge unabhängiger Pfade im Programmfluss an. Wird jeder Pfade des Kontrollflussgraphen einmal durchlaufen, ergibt sich eine Abdeckung von 100 % \cite[S. 100 f]{sl_basiswissen_sw_test}
						-> afferrente Kopplung beschreibt die Anzahl der Klassen außerhalb eines Paketes, die von Klassen innerhalb des Paktes abhängen (incomming), efferente Kopplung hingegen ist die Anzalh von Klassen außerhalb eines Paketes von denen Klassen innerhalb des Paketes abhängen (outgoing). Beschreibung für stabilität -> I = Ce / Ca + Ce -> Range [0,1] 0 ist stabil. \cite[S. 23-24]{martin_design_principles}
!						-> Warnungen und Code-Style sind nicht beseitigte Schwachstellen -> Java Code Conventions, welche Sun folgt und empfiehlt -> filenmaes, file-organisation, Einrückung, Kommentatare, Declarationen, Namensvergabe \cite{java_code_conv}
					- CI-System speichert Artefakte in einem Repository oder es können Systeme wie Nexus oder Artifactory genutzt werden -> Links zu Nexus und Artifactory
					- Binärdateien einer Version nur einmal kompilieren -> wird in allen Stages (Test etc.) benötigt -> mehrfaches Erstellen nicht empfohlen weil: \cite[S. 113]{CD}
						- kosten Zeit und ist deshalb nich effektiv
						- Binärdaten die in Produktion geliefert werden, sollten exakt identisch mit denen des Akzeptanztests sein.
						-> Gefahr, dass Änderungen während der Pipeline an der Quellcodebasis vorgenommen werden -> Dann unterschied zwischen getesteter und in Produktion released (Revisionssicherheit)
						-> Konfigurationsmanagement notwendig, da Binärdateien nicht für eine bestimmte Umgebung erstellt werden können -> felxibilität und wartbarkeit werden reduziert
				-> Automated Acceptance test stages:
					-> Prüft ob eine Anwendung in Produktion gehen kann -> RC?
					- Akzeptanztests: werden Kundenanforderungen erfüllt, ist die Spezifikation erfüllt, kann die Anwendung in Produktion deployt werden? \cite[S. 124]{CD}
					- System erfüllt funktionale und nicht-funktionale Anforderungen, Verhalten erfüllt die Bedürfnisse des Nutzers und die Spezifikation des Auftraggebers 
						-> Nichtfunktionale Tests: Kapazität / Sicherheit / Service-Level-Agreement \cite[S. 128]{CD}			
					- Regressionstest das keine Fehler sich in bestehendes Verhalten geschlichen haben \cite[S. 124]{CD}
					- Produktionsumgebung wenn komplex und teuer -> kleiner skallierte Version nutzen (kleine Anzahl von Middleware-Server)
					- Verhalten: schlägt eine Pipeline fehl, sollte dies unverzüglich behoben werden -> Verantwortung beim ganzen Team \cite[S. 125]{CD}
					- Fail bedeutet -> nicht fähig ausgeliefert zu werden \cite[S. 126]{CD}
					- längerlaufende Akzeptanztests -> Aufteilung in Suits (User Akzeptanz / Kapazität) für parallele Ausführung
				-> Manuell test stages: 
					- Das System ist bedienbar und erfüllt die Anforderungen. Hier werden Fehler aufgedeckt, die nicht durch automatisierte Tests abgedeckt werden können - Verifiziert, das Wert für den Anwender produziert wurde
					- Tester prüfen ob Akzeptanztests das Verhalten des Systems testen durch Validierung der Akzeptanzkriterien \cite[S. 128]{CD}
				-> Release stage / Deployment: 
					- Liefert das System aus (Paket oder Deployment in Staging / Produktivumgebung
					- Deployment muss auch Test-Systeme berücksichtigen \cite[S. 126]{CD}
					- Ansicht was aktuelle deployt ist! \cite[S. 126]{CD}
					- Visualisierung / Berichte / Autorisierung \cite[S. 126]{CD}
					- -> eigenes System: liste mit release-Kandidaten / Button zum deployen für Version und Umgebung der Wahl \cite[S. 126]{CD}
					- SSP für Tester, die eine bestimmte Version zum testen wählen können. \cite[S. 126]{CD}
				-> Zusätzliche Stages je nach Art des Lieferprozesses, müssen hinzugefügt werden			
		Ablaufsteuerung:
			- Gleiches Skript für Deployment, unterschiedliche Umgebungseinstellungen können Properties Files / Datenbanken / LDAP gehalten werden \cite[S. 115-116]{CD} 		
			- Pipeline-Trigger: \cite[S. 118-119]{CD}
				- SVN-Check-In -> erfolgreiche Stage triggert die nächste
				- Bsp: Build-Stage triggert Akzeptanz-Stage -> SVN-Ckeck-in einer neuen Version -> Build der jeweils neusten Version, Check-Ins dazwischen sollten ignoriert werden, wenn Akzeptanz-Stage fertig, neustes Build testen ....
			- Building on success / Bedingungen für den RC \cite[S. 132]{CD}
				- Code kompiliert
				- Code macht das was der Entwickler denkt, was er machen sollte (Unit-Test)
				- System macht, was die Analysten / Nutzer denken, was es sollte (Akzeptanztests)
				- Konfiguration und Infrastruktur wird gemanaged / analog zur Produktivumgebung
				- Alle Komponenten am Platz, da deployt werden konnte
				- Deployment System selbst arbeitet -> da es bei Entwicklungsumgebung / Akzeptanzumgebung / Testumgebung für Deployment schon angewandt wurde
				- Versionskontrolle hällt alles für das Deployment bereit, ohne manuelle eingriffe -> System wurde bereits mehrfach deployt
			- Nach Deployment Smoke-Test, der prüft ob die Anwendung läuft, sowie jeder abhängige Dienst (z.B. Datenbank) \cite[S. 117]{CD}
		Vorraussetzungen für DP:
			- Planung:
			- Vorgehensweise bei der Erstellung der Pipeline \cite[S. 133]{CD}
				- Wertstromanalyse des Prozesses + lauffähiges Skelett
					- Schritte niederschreiben mit Stift und Papier die im Prozess derzeit ablaufen
					- Stage für Stage konstruieren (Commit-Stage mit Test / Akzeptance-Stage / ...)
					- Neues Projekt -> lauffähiges Skelett mit Hello World (am besten vor der eigentlichen Arbeit)
				- Build + Deployment-Prozess automatisieren
					- Quellcode als Input -> Binärdatein als Output
					- jedes Mal nach Check-In -> CI-System
					- Deployen nach UAT env + Push-Button Deployment in Umgebung -> für jedes Build der Applikation (von CI) + Deplyoment-Test (Smoke)
				- Autom. Unit-Tests + Code-Analyse \cite[S. 135]{CD}
					- Teil der Commit-Stage
					- benötigen kein komplexes Set-Up / benötigen keine laufende Instanz der Anwendung
					- Laufzeit > 5 Minuten -> Aufsplitten in paralell laufende Suites
				- Autom. Akzeptanz-Tests
					- Akzeptance-Test-Framework Start-up -> Reports einsammeln am Ende des Durchlaufs
					- funktionale / nicht funktionale Anfordeurngen
				- Autom. Release auf Produktion
				- Komplexe Anwendungen / Komponenten
					- komplexe Anwendungen in kleinen eigenen Pipelines bauen und testen
					- alles zusammenfügen und Komplettsystem testen
				-> inkrementell implementieren
				-> Daten sammeln, wann gestarten, wann welche stage ... -> auswertung
				-> Pipeline ist eine "lebendes System" und muss stetig weiterentwickelt und angepasst werden \cite[S. 137]{CD}
			- Infrastruktur:
				- Test ~= Produktion: netzwerk-Topologie / firewall, OS + patchen, App-Stack, Applikationsdaten
			- Organisation:
				- Automatisiertes Deployment: Problem häufig da nicht ausreichende Kontrolle über Produktionssystem \cite[S. 129]{CD}
					-> Alle Änderungen am System sollten automatisiert erfolgen (Konfiguration / SW-Stack / Netzwerk-Topologie / State)
					-> Probleme lassen sich schnell verfolgen / Konfigurationen zurücksetzen ... (bei Skripte + SVN) -> bessere Wartbarkeit
		Exk.: Build und Deployment Skripting:
			- Ermöglicht die Pipeline und ist Grundtechnik um Binaries zu erstellen 
				-> auch unterstützung zur Auslieferung auf die Zielplattform vorhanden.
			- "Skript" als weiter Bereich der Automatisierung von Aufgaben gemeint
			- Build-Tool - Aufgabe: Netzwerk von Abhängigkeiten modelieren
			- Verschiedene Tools am Markt, im Java-Umfeld Ant und Maven \cite[S. 147-149]{CD}
				- ant \cite[S. 147-148]{CD}
					- Task-orientiert
					- XML als DSL zur def von Tasks
					- Kompilierung / Filesystem-Tasks
					- cross-plattform Kompatibel
				- maven \cite[S. 149-]{CD}
					- onvention over configuration -> Projektstruktur durch Maven vorgegeben
					- automatisches Management von Java libs
					-> Maven Autoupdate kann Build-fehler verursachen -> unvorhersehbar  -> mglw. nicht reproduzierbare Build!
			- Prinzipien:
				- Je Stage eine Build-Skript
					-> dem Domain-Driven-Design entlehnt \cite[S. 152]{CD}
					-> Deployment-Pipeline hat organisationsprinzip um Verantwortlichkeiten zwischen Build-Skripts aufzuteilen
				- Erfordert Zusammenarbeit von Entwicklern und IT-Betrieb -> DevOps
				- OS-Spezifisches Packetierungs-Werkzeug nutzen, da dann Tools wie Puppet genutzt werden können, um Pakete zu verteilen:
				- ....
				- Zurückverfolgung von deployten Binärdaten zur Versionsnummer der Versionsverwaltung \cite[S. 165]{CD}
				- Binärdatein sollten nicht in das Versionsverwaltungssystem eingecheckt werden \cite[S. 166]{CD}
					-> steht in Konflikt mit Nummernsystem der Versionsverwaltung
					-> geteiltes Dateisystem (e.g. Netzlaufwerk / FTP ...) um Binärdatein und Berichte zu verwalten
			- Schritte:
				- Umgebung einrichten: Script muss häufig auf verschiedenen Systemen laufen
					-> Datenbank upgraden, neue Binärdatei deployen, Dienst von dem die Anwendung abhängt aktualisieren \cite[S. 161]{CD}
					-> Software-Layer muss beachtet werden (Hardware - OS - Middleware - App / Service / Komponenten + jeweilige Konfiguration) \cite[S. 162]{CD}
					-> nach HF drei Möglichkeiten: \cite[S. 161]{CD}
						- Skript, welches sich auf die Systeme einloggt und Änderungen durchführt 
						- Lokales Skript, wird durch Agents auf allen Systemen ausgeführt
						- Package der genutzten Platform bauen + Infrastruktur-Management-Tool das die Änderungen übernimmt (besste Option)

	Implikationen für das Liefersystem:
		- Liefersystem besteht aus Infrastruktur und Umgebungen
		- besonderer Fokus auf Datenbanken, Abhängigkeiten und Versionsverwaltung
			- Anwendung in der Deployment-Pipeline benötigt Daten-Management -> Datenbanken müssen für neue Funktionalitäten vorbereitet werden
			- Anwendung hängt von weiteren Komponenten / Bibliotheken ab -> Abhängigkeiten müssen vor Auslieferung organisiert werden
			- Im Versionsverwaltungssystem können Probleme durch Branching und Merging entstehen
		Schnittpunkte von CD bei IT-Infrastruktur und Systemumgebungen:
			- Auswirkungen auf den IT-Betrieb:
				- in mittleren und größeren Unternehmen ist IT-Betrieb eigene Organisationeinheit
				- Dokumentation und Betriebspürfung / Revision 
					- nach ITIL ist deployen von Änderungen in Umgebung ein Prozess nach Change-Management \cite[S. 89 ff]{itil_boetcher}
					- Erfordert Dokumentation von RFCs, diese müssen beurteilt, auf Risiken geprüft und authorisiert werden
					- Dev-Team muss sich auf Situation einstellen und den Prozess rechtzeitig mit Ops durchgehen  \cite[S. 182]{CD}
					- sollte deshalb zum release-plan gehören
				- Alarme
					- Monitoring-Systeme werden duch Ops verwendet um die Infrastruktur zu überwachen
					- Dev muss Systeme vor Entwicklung kennen und die integration in diese berücksichtigen und planen  \cite[S. 182]{CD}
					- Wo sind Log-Files und wie wird auf Fehlverhalten aufwerksam gemacht
					- Ziel ist die fähigkeit Ops die Anwendung neu deployen / neu starten zu lassen
				- es sollten nur Technologien verwendet werden, die vom IT-Betrieb beherrscht werden
					- Planung aus Dev zu beginn der Entwicklung heraus, wie deployt werden soll  \cite[S. 282]{CD}
					- Vereinbarung (Dev-Ops) über verwendete Skript- / Paket-Technologie  notwendig [Ruby, Perl, Python, Debian-Package, ...]  \cite[S. 283]{CD}
			- Auswirkungen auf das Management der Infrastruktur:
				- Infrastruktur berührt die Domaine des IT-Betriebs, muss modeliert und verwaltet werden
				- Verbundene Fragestellungen:  \cite[S. 284]{CD}
					- Wie wird provisioniert?
						- Innerhalb der Deployment-Pipeline notwendigkeit Server flexibel provisionieren zu  können, z.B. um automatisierte Test parallel durchführen zu können	
					- Wie wird deployt und konfiguriert?
						- Middelware (z.B. für verteielte Systeme [Application-Server, RMI, ...]) muss dann konfiguriert werden
					- Wie wird die Infrastruktur verwaltet?
						- Zugriffskontrolle zur Infrastruktur um Änderungen durchführen zu können
				Lösungsvorschlag von HF:
					- Provisionierung von Infrastruktur:
						- Abhilfe: Nutzung von Virtualisierung und Cloud-Computing für Provisionierung von Servern, bzw. zum starten von vorkonfigurierter Systeme
						- Keine Änderung am System ohne vorherige Zustimmung (von wem?)
						- automatisierte Prozesse um Änderungen an der Infrastruktur vorzunehmen (SVN-Check-In)
						- Deployment-Pipeline sollte vor Deployment testen, ob die Anforderungen an die Infrastruktur getroffen worden sind
						- Testumgebung für Änderungen an der Infrastruktur \cite[S. 287]{CD}
						- Problem, wenn Infrastruktur mit anderen Systemen geteilt wird. -> keine Veränderung der Konfiguration möglich ohne Seiteneffekte auf anderes System
						- Server-Provisionierung und Konfiguration Managen
							- Infrstrukturdienste nutzen? Virtualisierung?
							- Wie werden Server provisioniert -> Technik
							- Betrieb und Verwaltung der Server
					- Konfiguration von Middelware:
						- Nach Möglichkeit sollte Konfiguration per Skript für OS und Middleware in Versions-Verwaltung hinerlegt sein  \cite[S. 285]{CD}
						- Middelware Konfigurieren
							- Konfigurationen verwalten
							- Produkte müssen dafür untersucht werden
							- Wie werden Zustände in der Middleware gesteuert -> können diese beeinflusst werden?
							- Konfigurations-API, die die Configuration programmatisch übernimmt?,
					- Monitoring:
						- Infrastruktur überwachen -> Änderungen überprüfen -> Änderungsverlauf überprüfen
							- Daten sammeln
							- Logging
							- Instrumentenpult erstellen, die den Zustand und das Verhalten der Applikation anzeigt
		Kritische Komponenten in der DP:
			Datenbankupdate in der DP:
				- Datenbank als kritische Komponente während des SW-releases
					- z.B. Neue Funktionalität in Web-Anwendung soll Deployt werden, die eine Änderungen an einer Tabelle erfordern
					- Problem z.B. bei inkrementelles Update einer Web-Anwendung, die unterschiedliche DB-Versionen nutzen
						-> Was passiert mit Nutzertransaktionen auf alter DB-Version
						-> Anwendung kann nicht live gehen, wenn dies nicht geklärt.
					- Datenverlust duch Release vermeiden
						- Fehlschlag beim Release -> Rollback der DB schnell, einfach und automatisiert?
					- Vorbereitung und Organisation von Persistenz auf der die Anwendung arbeitet
				- Lösungsmöglichkeiten:
					- Inkrementelle Ändeurngen an Datenbanken
						- Zu beginn aufsetzen der Datenbank
						- Wenn neue Tabellen benötigt werden, können z.B. "ALTER TABLE" Anweisungen ausgeführt werden
						- Im Skript müssen auch UNDO-Operationen vorgesehen werden, um die Änderungen rückgängig zu machen
						- Versionierung: Notwendig im Skripte zu ermitteln ob Skripte ausgeführt werden können.
						-> Tool, welches den aktuellen Stand der Datenbank überprüft und das x+1-Skript ausführen kann. (Tool:DbDeploy) \cite[S. 328]{CD}
					- Datenbank-Rollback
						- Datenbanken + Anwendung zurücksetzen können, wenn beim Deployment etwas schief geht: \cite[S. 332]{CD} (Blue-Green-Deployment)
							1. Datenbank-Backup erstellen und auf zweiten DB-Server einspielen (z.B. durch Provisionierung)
							2. Änderungen an der Datenbank vornehmen und Funktion testen (Änderungsskript, Test mit SQL-Befehl)
							3. Server für Anwendung provisionieren, einrichten und Anwendung deployen -> neue Instanzen greifen auf neue Anwendung zu.
							4. laufende User auf neue Version übertragen und Server mit alter Version stoppen.
							5. Delta der alten DB von Backup-Time bis Stop der alten Version auf neue DB übertragen
							-> geht bei der Änderung der kopierten DB etwas schief, kann deployment gestoppt werden
							-> Hat die alte Anwendung fehler, kann DB-Backup eingespielt werden. Delta an neuer DB muss aber in alte übernommen werden
					- Entkopplung Anwendungs- und Datenbankänderung \cite[S. 333]{CD}
						- wird zwischen zwei Deployments ausgeführt
						- wenn neue Version sich als stabil erwiesen hat
						- Versions-Bedingung der DB für Applikations-Version -> app v248 ist kompatibel mit db v15 -> z.B. über Konfig-Info vor Deployment DB-Version abfragen (Grafik \cite[S. 333]{CD})									
			Strategien für die Versionsverwaltung:
				- Branching und Merging 
					-> Branch erzeugt einen paralellen Entwicklungszweig \cite[S.154-159]{popp_konfig}
					-> SVN bietet hierfür den separaten Ast Branch an, während der Hauptstamm im Trunk verbleibt
					-> Warum Branches? 
						- parallele Entwicklung am Branch für Feature, während auf dem trunk das release vorbereitet wird \cite[S. 157]{popp_konfig}
						- Integrations-Branches \cite[S. 389]{CD}
						- Wartungs-Branches
					-> Merging führt Branches zusammen \cite[S. 390-393]{CD}
						- aufwändig wenn differenzen groß und eine Menge Anpassungen notwendig sind den Branch in den Hauptstamm einzufügen 
						- Kontinuierlich mergen: Branches nur für kurze Zeit zuzulassen, 1-2 Tage, verringert die Nachteile des Branchings 
						- Empfehlung:
							- Branch nur für Releases
							- Änderungen immer am Trunk
							- Mergen nur für BugFixes am Release (Trunk -> R-Branch)
	Zusammenfassung:
		-> Anforderung aus dem ITIL-Release-Management schon früh umsetzen -> wenn Problem erst kurz vor dem Release auftauchen kann es hektisch werden (DevOps)

4. Entwicklungsstand CD:
	- Entwicklung von Lösungsstrategien für adesso setzt Betrachtung des derzeitigen Auslieferugsprozesses vorraus.
	- Es wird keien heterogene Projektlandschaft erwartet, unterschiedliche Projekte haben unterschiedliche Anforderungen
	- Erwartung, des es schon Bemühungen in Richtung CD gibt.

	4.1 Ausgangssituation für die Untersuchung: (Grund der Untersuchung, Ansatzpunkte für CD zu finden)
		- Technologische Unterscheidung der Projekte nach Java, MS, Mainframe, CMS, Fokus aber auf Java / JEE
		- CI-System bei adesso für Kompilierung und Integrationstest sorgt für Klarheit über Stand des Projekes
		- Bereitstellung eines spezialisierten support Teams -> Aufgaben Einrichtung der Prozesse und Beratung
		- Grund für Untersuchung IST-Zustand ist die Integratiosfähigkeit der Werkzeuge sowie Prozesse
		- Untersucht wird mit dem Reifegradmodell für CI von UrbanCode -> Warum ist es geeignet?
		- Gewinnausnutzung von kurzen Iterationen und entwickelten Programmfunktionalitäten benötigt Anpassung des Auslieferungsprozesses
	
	4.2 Erhebungsmethode: (Welche Methoden sind möglich, welche Form wird gewählt)
		- Ausliefreungsprozess unterliegt unterschiedlichen Rahmenbedingungen
		- CI-Team bietet spezialisierte Kenntnisse rund um das Thema Auslieferung und Integration an.
		- CI-Team ist geeignet den Auslieferungsprozess darzustellen
		- Meinungen und Standpunkte sowie Prozessbeschreibungen sollen befragt werden
		- Möglichkeiten der Befragung: Interview, Fragebogen
		- Kleiner Nutzerkreis spricht für Interview aber zeitaufwand und asynchrones Antwortverhalten begünstigt Fragebogen
		- Der Fragebogen wird präferiert wegen asynchronität
		- Zusammensetzung Fragebogen: wenigen Textfeldern, mehr Zustimmungsfragen, Felder für Anmerkungen
		- Zustimmungsfragen kommen aus Refegradmodell von UrbanCode und Anti-Pattern von Humble / Farley
		- Reifegradmodell ist für Selbstevaluierung bestimmt, derzeit keine weiteres bekannt
		- Unterteilung des Fragebogens in Sektionen Commit-Stage, Acceptance-Stage, Deplyoment
		- Commit-Stage für Build-Prozess, Acceptance-Stage für Integratios- und Abnhametests, Deployment kritische Komponente der Auslieferung
	
	4.3 Auswertung und Darstellung der Ergebnisse: (Was hat die Untersuchung gebracht)
		- Antwort von drei Mitarbeitern des CI-Team, repräsentativ, da dies wesentlicher Kern
		- keine vollständige Deckung der Antworten, deshalb Vermutung keine durchweg standardisiertes Verfahren
	
		4.3.1 Phasen des derzeitigen Auslieferungsprozessen
		- Phasen: Projekt-Setup, Entwicklung, Integrationstest, Auslieferung
		- Abhänig vom Auftraggeber
		- Entwicklung umfasst die Subphasen Build, Unittest, autom. Deployment auf Test, Bevorzugung von TDD
		- Kein Zugriff auf die Produktivumgebung, nur Ausliefreung von WAR / EAR
		
		4.3.2 Commit-Stage:
		- Jenkins CI-Server mit Maven / Ant als Build-Tool
		- Zentraler Prozess -> Anti-Pattern: Build-Prozess auf Entwickler-PC nicht replizierbar und instabil
		- Softwarepakete werden mit Versionsummer versehen im zentralen Repository abgelegt und keine zweites Mal gebaut
		- Anti-Pattern: Build-Prozess der selben Version wird wiederholt
		- 3rd Party Libs mit Maven in zentralen Repository (Nexus)
		- Automatische Prozessauslösung für Build und Test
		- Nutzung CI-System Abhängig vom Projekt von Team, aber streng empfohlen !!!
		
		4.3.3 Acceptance-Stage:
		- Software muss Qualitätskriterien / Abnahmekriterien entsprechen
		- keine forcierung von 100% Testabdeckung -> wäre auch trügerisch!!!
		- statische Analyse mit Sonar
		- Weitere Werkzeuge wie FindBugs, PMD, JoCoCo, Cobertura
		- Testverfahren auf das Gesamtsystem gegen funktionale und nicht-funktionale Anforderungen
		- Automatisierte Akzeptanztests geben schnelle Rückmeldung welche Anforderungne erfüllt werden
		- Prozess: 1. SVN-Check-In 2. Kompilieren 3. alle Tests -> Dadurch Regressiostest!
		- Testberichte zeigen nur auf welche Tests (nicht) erfolgreich verliefen
		- !!! Welche Inhalte sollte ein guter Testbericht haben?
		
		4.3.4 Deployment:
		- Deploymet liefert Software in Ausführungsumgebung (Test / Produktion)
		- Commit und Acceptance kann zu Deployment führen, aber Vorbereitung notwendig z.B. für Jenkins, Tomcat, JBoss, Ant und Maven
		- Ausliefern in Cloud oder VM hochfahren mit Chef, schon bei adesso als Projekt verwendet
	
	4.4 Anknüpfungspukte für CD: 
	- Wenn möglich sollte kompilieren und testen automatisch auf CI-Systemen ausführen
	- Hoher Aufwand wenn zu spät integriert wird und Fehler entdeckt werden -> komplex Systeme
	- Wenn nur WAR- und EAR-Files geliefert werden ist kein Zugriff auf Produktivsystem möglich
	- Rechtliche Implikationen schränken dieses Verfahren auch ein
	- Agiles Vorgehen z.B. Scrum oder advantage produzieren zu erst die wichtigen Funktionalitäten -> sollte auch vom Kunden direkt getest werden können
	- Empfehlung für vorkonfigurierte Tool-Chain mit Deployment-Tool für Self-Service-Portal um CD und Deployment-Pipeline anzubieten
	- Geeignete Tools sollen im nächsten Kaptiel untersucht werden

5. Evaluierung der Werkzeuge:
	- Evaluierung von Go, Deployinator, Dreadnot -> sind durch adesso vorgegeben
	- Werkzeuge stehen im Zusammenhang mit CD: Ziel Komplexität von CD veringern
	- Komplexitäten durch:
		- unsicherer Prozess wenn automatierung nur aus Script-Sammlung besteht
		- Ausrollen von Webanwendungen in Produktion -> Installation Server und Infrastruktur
	- kein unverseller Problemlöser erwartet, möglicher Weise sind Tools in verschiedenen Kategorien beheimatet
	- CD umfasst die Konzepte von CI, CI System schon vorhanden (Jenkins)
	- Deployment-Pipeline in Web-Server bei adesso durch Jenkins-Plug-In schon möglich
	- Zu untersuchende Werkzeuge stehen in Konkurrenz zum bestehenden System
	
	5.1 Kriterien für die Evaluierung:
		- Soll klären ob die Werkzeuge die Deployment-Pipeline bei adesso verbessern könnten
		- Genauer Funktiosumfang der Werkzeuge vorab noch nicht bekannt -> eingehende Grobbetrachtung notwendig
		- Einordnung in Werkzeugklassen: Go -> CI-System, Deployinator und Dreadnot -> Self-Service-Portal für Deplyoment
		- Grundlegene Eigenschaften für Einrichtung, Betrieb und Integration in Umgebung sind vergleichbar
		- Funktionsumfang für CD setzen an unterschiedlichen Ende, möglicherweise ein gegenseitige Ergänzung von CI <-> SSP 
		- Deshalb Untersuchung welche CD-Funktionen abgebildet werden nach Management, Commit-, Acceptance-, Deployment
	
		5.1.1 Kriterien für Einrichtung, Betrieb und Integration
		- Installationsanweisungen
		- Installatiosverhalten und 
		- Systemvoraussetzungen
		- Möglichkeiten das System zu integrieren
		- Lizenzen / Kosten
		
		5.1.2 Anforderungen für eine Deployment-Pipeline aus CD
		- nach CD, unterscheidung der Anforderungen nach Stages
		
		5.1.2.1 Management von CD
		- Prozess abbilden
		- Quality Gates
		- Prozess-Trigger
		- Reporting Build, Test, Metriken
		
		5.1.2.2 Commit-Stage
		- Unterstützt Versionsverwaltungssysteme (SVN,CVS,Git)
		- Build-Tools anstoßen (Ant,Maven,?)
		- Repository für Artefakte
		- Unit-Tests (JUnit)
		- Code-Analyse (Sonar, FindBugs, etc.)
		
		5.1.2.3 Acceptance-Stage
		- Konfiguration Testumgebung
		- Binärdaten deployen
		- Smoke-Test
		- Akzeptanztests
		
		5.1.2.4 Deployment
		- Self-Service-Deployment
	
	5.2 Ergebnisse:
	
		5.2.1 Go
		- Setup:
		
		- Implementierung einer Pipeline:
			- HF empfehlen wenn noch kein Projekt vorhanden: funktionierendes Skelett mit "Hello World" \cite[S. 132]{CD}
			- Implementierung eines Testprojektes um Go zu testen
				
		5.2.2 Deployinator
		- Setup:
		
		- Implementierung einer Pipeline
			- Nutzung des Testprojektes von Go
		
		5.2.3 Dreadnot
		
	5.3 Vergleich zum derzeitigen Auslieferungssystem
	
	5.3 Zusammenfassung:
	- Zwei unterschiedliche Kategorien von Werkzeugen -> CI-System vs. Self-Service-Portal für Deployment
	- Keines ohne Anpassung geeignet
	- Dreadnot bieten gute Deployment Unterstützung, Mölichkeit als SSP in Lieferprozess zu integrieren

6. Lösungskonzept für CD bei adesso:

	6.1 Szenario
		- Einsatz von embedded Server verringert Komplexität -> Jetty, aber nur JSP Seiten, für Tauschplattform aber geeignet
		- Abnahme auf Testsystem
		- Einrichten eines Selfservice Portal um Version von Test auf Produktion zu bringen -> Teilabnahme damit erfolgt
		- Muss als Aufgabe im Projekt betitelt werden
	
	6.2 Prozessegestalltung
		- Tools: SVN -> Jenkis CI -> Dreadnot / Deployinator
		- Infrastruktur: SVN (externes System) -> CI-Server + Dreadnot + Puppet / Chef -> Deployment zu Node-System
	
	6.3 Konzep einer Deployment Pipeline
	
	6.4 Werkzeugkonfiguration

7: Fazit:
	- "CD zu implementieren erfordert mehr als nur Werkzeuge zu kaufen und automatisierung zu implementieren, es hängt viel mehr von einer effektiven Zusammenarbeit ab aller im Auslierfungsprozess beteiligter. \cite[S. 417]{CD}